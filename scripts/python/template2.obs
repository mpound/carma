# Template observing script
# Based on: ScienceTemplate27Sep06.py
#
# @author John Carpenter
# $Id: template2.obs,v 1.34 2010/06/16 21:16:52 jmc Exp $
#
#   History
#   2007-Feb-27  JMC    Copied from template1.obs to support new format
#   2007-Mar-19  JMC    Added pointing for flux and passband calibrators,
#                       and pointing at 95 GHz
#   2007-May-27  JMC    Added calibrator searches at start of track
import obsdef2 as od

"""
Contact person for project cxxxx
     Name        :
     Email       :
     Office phone:
     Home   phone:

--------------------------------------------------------------------------------
Instructions for the observers:
--------------------------------------------------------------------------------

Source : s255
RA     : 06:10:00.00
Dec    : +18:00:00.00

Rise/Set LST times for source/phase-calibrator at elevation of 30.0 degrees
          Source       Rise        Set
            s255    01:47:40   10:32:20  --- Up for 8.7 hours
        0530+135    01:21:16   09:40:36  --- Phase calibrator
"""

# ----------------------- OPTIONS SPECIFIED BY THE PI ------------------------
# Project information
projectInfo = {
   'emailAddress'  : 'address@astro.univ.edu',
   'code'          : 'project',
   'obsblock'      : 'project.1D_test',
   'subobsblock'   : None,
   'sourceCatalog' : 'my_catalog.cat',
  }
  

# Tuning options
tuning = {
   #'restfreq' : linefreq('12CO(1-0)'), # Alternate way to specify rest frequency
   'restfreq' : 230.0,  # [GHz] Line rest frequency
   'sideband' : LSB,    # Sideband for first LO (LSB or USB)
   'IFfreq'   : 3.00,   # [GHz] IF frequency
  }


# Correlator configuration
# For best sensitivity, the band should be placed at an IF frequency > 2 GHz.
# Also, the band should not overlap IF=5 GHz.
configband(1, BW62, tuning['restfreq']+0.5)
configband(2, BW62, tuning['restfreq'])
configband(3, BW62, tuning['restfreq']-0.5)
configband(4, BW62, tuning['restfreq']-1.0)
configband(5, BW62, 'offline')


# Correlator configuration for calibrators
# reconfig: Sets correlator configuration for calibration observations
#     None                  : same as for science targets
#     od.utils.CORR_BW500LO : 500 MHz, non-overlapping bands 
#     od.utils.CORR_BW500   : change bands to 500 MHz without changing IF
# hybrid:   Correlator configurations to calibrate band offsets (see FAQ page!).
#           Needed only if all bands have width < 500 MHz.
# tintHybrid : integration time in minutes for each of hybrid correlator mode
correlator = {
   'reconfig'   : None,
   'hybrid'     : None,
   #'hybrid'  : [ [BW500, BW62,  BW62],  [BW62, BW500, BW62] ],
   'tintHybrid' :  5.0,
  }


# Names for phase calibrators and science targets.
# Enter multiple science targets as 'target' : 'ABAur,GMAur'
# Enter multiple phase calibrators as 
#     'phaseCal' : [ '3c111     1:00:00  4:00:00',
#                    '0530+135  3:30:00  7:00:00']
# tintTarget: Integration time per cycle **per pointing** on science targets
# tintPhase : Phase calibrator integration time per cycle
# callist   : Used to search for bright phase calibrators. See online manual.
sources = {
   'target'       : '3c279',
   'phaseCal'     : '3c273',
   'tintTarget'   :   5.0, # [minutes] 
   'tintPhaseCal' :   3.0, # [minutes] 
   'callist'      :  None,
  }


# Mosaic options
mosaic = {
   'doMosaic'   : False, # If True, make a mosaic
   'startpos'   :     1, # Starting mosaic position 
   'nphase'     :     0, # Number of positions to observe between phase cal
                         # observations. 0 -> Observe all positions.
   'arcminUnits':  True, # If True, offsets are in arcminutes. If False,
                         # offsets are in units of the Nyquist sampling rate
                         # of the large antenna in the subarray
   'offsetFile' :  None, # Offset data file (e.g. 'm51_mosaic.dat')
   'offsets'    :  None, # List containing the offsets.
                         # This can be used instead of offsetFile.
                         # e.g. [ [-0.5,0.5], [0.5,-0.5], [-0.5,-0.5]]
  }


# Pointing options
pointing = {
   'doPointNight' : True,
   'doPointDay'   :  True,
   'doOptPoint'  : False, # Use optical pointing
   'intervalNight':  4.0, # [hours]  How often to point during nighttime
   'intervalDay' :   2.0, # [hours]  How often to point during daytime
   'intervalOpt' :   0.5  # [hours]  How often to perform optical pointing
   'minflux'     :   4.0, # [Jy]     Minimum pointing flux
   'maxsep'      :    50, # [degree] Maximum distance from science target
   'preferred'   :  None, # Preferred pointing source
   'nrepInt'     :     1, # Number of repeat observations per position
   'mapPoints'   :     5, # Make a strip in az/el with mapPoints positions
   'tune95'      : False, # Tune to 95 GHz before pointing
  }


# Passband options
passband = {
   'doPassband' : True,  # If True, observe passband calibrator
   'doPoint'    : True,  # Point up on passband calibrator if needed
   'forcePoint' : False, # Force pointing if source is available
   'tint'       :   5.0, # [minutes] Passband calibrator integration time
   'minflux'    :   4.0, # [Jy]      Minimum flux density for passband cal
   'preferred'  : None,  # Preferred passband calibrator
   'middle'     : False, # OK to observe in middle of phase/source cycle?
   'ncal'       :     1, # Maximum number of calibrators to observe per track
   'interval'   :  None, # [hours]   How frequently to perform passband cal
  }


# Flux calibration options
fluxcal = {
   'doPrimary'    :  True, # If True, observe primary flux calibrators
   'doSecondary'  :  True, # If True, observe secondary calibrator if primary
                           # calibrator is not available
   'doBoth'       : False, # Observe both primary/secondary cal in each cycle
   'doPoint'      :  True, # Point up on flux calibrator if needed
   'forcePoint'   : False, # Force pointing if source is available
   'tint'         :   5.0, # [minutes] Integration time per calibrator
   'preferredPri' : None,  # Preferred primary calibrators
   'preferredSec' :  None, # Preferred secondary calibrators
   'ncal'         :     1, # Number of calibrators to observe per cycle
   'ncycles'      :     1, # Maximum number of calibration cycles in track
   'interval'     :  None, # [hours] How often to repeat calibration cycles
   'middle'       : False, # OK to observe in middle of phase/source cycle?
  }


# Indicate, True or False, which primary flux calibrators are ok to use.
# Add sources to the list as needed.
primaryFluxCalibrators = {
   'jupiter'  : False,
   'mars'     : True,
   'neptune'  : True,
   'uranus'   : True,
   'mercury'  : False,
   'mwc349'   : True,
  }

# Set various limits for observations
# minElevationCal  : Minimum elevation for flux/passband/pointing sources
# maxElevationCal  : Maximum elevation for flux/passband/pointing sources
# trackingThreshold: Data are flagged if tracking error is larger than limit.
# record           : Record length for integrations (except noise source)
# tmoTrack         : Timeout when acquiring a source
# tsys             : Time between full tsys measurements
# count            : Number of antennas to arrive on source before integrating
limits = {
   'minElevationCal'   :  30.0, # [degrees]
   'maxElevationCal'   :  80.0, # [degrees]
   'trackingThreshold' :   0.1, # [beamwidths]
   'record'            :  30.0, # [seconds]
   'combine'           :  20.0, # [Number of 0.5 second records to average]
   'tmoTrack'          : 500.0, # [seconds]
   'tsys'              :  10.0, # [minutes]
   'antwait'           :    -2,
  }


# Noise source parameters
noise = {
   'tint'   :    2, # [seconds] Integration time for noise source
   'record' :    2, # Record length for noise integration only
   'tsample': None, # [seconds] How frequently to observe the noise source
                    # during an integration
  
  }

# ----------------------- END OF PI SPECIFIED OPTIONS --------------------------


# -----------------------     MAIN PART OF SCRIPT     --------------------------

# Initialize system
od.initializeTrack(sources, mosaic, projectInfo, limits, pointing, passband, 
                   fluxcal, restart=restartScript, scriptName=scriptName, 
                   scriptOptions=scriptOptions, noise=noise)


# Check that sources are in the current catalogs
trackMessage('Verifying source names')
od.utils.checkSources(sources['target'], indent=1)
od.utils.checkSources(sources['phaseCal'], indent=1, isPhase=True)
od.utils.checkSources(sources['callist'], indent=1)
od.utils.checkSources(fluxcal['preferredPri'], indent=1)
od.utils.checkSources(fluxcal['preferredSec'], indent=1)
od.utils.checkSources(passband['preferred'], indent=1)
od.utils.checkSources(pointing['preferred'], indent=1)
od.utils.checkSources(primaryFluxCalibrators, indent=1)


# Tune receivers
if od.utils.tuneReceivers():
    trackMessage("Tuning freq=" + str("%.3f" % tuning['restfreq']) + " GHz, " + 
          str(tuning['sideband'])  + ", IFfreq=" + str("%.3f" % tuning['IFfreq']) + " GHz")
    freq(tuning['restfreq'], tuning['sideband'], tuning['IFfreq'], \
         od.utils.getSourceName(sources['target'], n=1, parse=True))
    optimizeThresholds()
    flattenPhases()
else:
    flattenPhases()


# Set the correlator configuration for calibrations observations if it is
# different from the science observations.
checkbands()
if not correlator.has_key('configCal'): correlator['configCal'] = None
if correlator.has_key('reconfig') and correlator['reconfig'] <> None:
    trackMessage('Determining correlator configuration for calibrator observations')
    correlator['configCal'] = od.utils.setCorrCal(correlator['reconfig'], 
              custom=correlator['configCal'])
else:
    correlator['configCal'] = None


# Set IF levels in antennas/downconverters for calibrator correlator config.
od.setIFLevels(correlator)


# Send email indicating track has started.
# fullScriptName and scriptOptions are set in run().
if od.utils.emailScriptLog(): 
    od.utils.sendEmail(projectInfo['code'], projectInfo['emailAddress'], 
                 fullScriptName, scriptOptions,
                 start=True, restart=restartScript)


# Measure optical-radio pointing vector, if needed
if pointing['doOptPoint']: od.measureOptradVector(pointing, correlator)


# Flux calibration
od.doFluxcal(fluxcal, primaryFluxCalibrators, noise, correlator, pointing,
             ref=sources['target'], start=True)


# Passband
od.doPassband(passband, correlator, noise, pointing, ref=sources['target'], 
              start=True)


# Radio pointing
od.doPoint(pointing, ref=sources['target'], correlator=correlator, start=True)


# Choose phase calibrator. Only meaningful if sources[callist] is set.
sources['phaseCal'],sources['tintPhaseCal'] = \
      od.findCalibrator(sources, correlator=correlator)


# Observe passband calibrator until source and first phase calibrator are up
pname, tstart, tstop = od.utils.getPhaseCal(sources['phaseCal'], split=True)
waitingForSource = not sources['doSnapshot']
while waitingForSource:
    dt = od.utils.timeRemaining(source=sources['target'], phase=pname, 
              lsttime=od.utils.getLstStartCycle(default=tstart), toRise=True)
    if dt > 0:
        trackMessage('Waiting for source to rise - observing passband for ' 
                        + od.utils.dtString(dt))
        ok = od.doPassband(passband, correlator, noise, pointing,
                           lststop=tstart, ref=sources['target'], force=True)
        if not ok: waitingForSource = False
    else:
       waitingForSource = False


# Cycle between source and phase calibrator.
od.doSourcesPhasecal(sources, fluxcal, pointing, passband, correlator,
                     noise, mosaic=mosaic, primaryCal=primaryFluxCalibrators)


# Passband observations
od.doPassband(passband, correlator, noise, pointing, ref=sources['target'])


# Flux calibration
od.doFluxcal(fluxcal, primaryFluxCalibrators, noise, correlator, pointing,
             ref=sources['target'])


# Print track summary
od.utils.trackSummary()


# Send email indicating track is finished
if od.utils.emailScriptLog(): 
    od.utils.sendEmail(projectInfo['code'], projectInfo['emailAddress'], 
                 fullScriptName, scriptOptions, msg=od.utils.getTrackHistory())


# Done
if s.getScriptBool(od.INDX_BOOL_PACS): 
    od.pacs.cleanup(s.getScriptString(odi.INDX_STR_PACS_OBSBLOCK))
resetProject()
if endTrackAlarm(): alarmon();
