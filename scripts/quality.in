#!/bin/tcsh -f
#
# CARMA quality script by Tony Wong (wongt@illinois.edu).
#
# NOTE: If you edit this script, make sure you get the latest version from
# CARMA/scripts:  $Id: quality.in,v 1.115 2014/04/16 05:39:29 volgenau Exp $
#
# When running offsite, the script expects the miriad data file to be in
# the current directory, and puts the results in the subdirectory quality/.
# These can be overridden with keywords DATADIR and SCRATCH.  The CARMA
# program meanmed should also be in the PATH; if not give its full path as a
# keyword: meanmed=/home/bin/...
#
# Recent history (yymmmdd):
#    09jun17   nv   For 1mm data, use tau from tipper, without converting to
#                   pwv and back. Change slope of finscore calculation to 20.
#    09jun30   nv   Revise grade calc for zenith opacity. Slope of finscore
#                   calculation should be config dependent. E=16, D=21, C=19,
#                   B=19, Bw/PACS=14, Aw/PACS=13
#    09dec11   nv   Change qualityGrade to specify imr=acc
#    10jan19   nv   bsln lengths at 1mm wavelengths need 7 digits; change
#                   bsln.out calculation from "print" to "printf %d\n".
#    10may07   tw   Source image plots have nxy=4,2
#    10may19   tw   Tidy up appearance of cgdisp plot; ensure correct IF order
#    10jul12   tw   Default 1-minute averaging at start of processing
#    10jul13   tw   Don't uvaver by default
#    10jul29   rx   custom processing block for handling different types of data
#    10aug01   rx   change default settings according to data types
#    11aug08   tw   Major rewrite: enable dual-pol & rationalize recent changes;
#                   removed support for hybrid mode to reduce complexity
#    11aug09   tw   make single continuum map for SZA data (Erik L.)
#    11sep28   tw   fix units on single continuum map; use /tmp folder;
#                   reduce use of uvaver/uvwide
#    11oct01   tw   Drop bad windows for CARMA-23; Tsys flagging
#    11oct18   tw   Show linelengths for all 23 ants in SZA mode
#    12feb08   nv   Do PB cal for first wide band (FWB). Find selfcal gains 
#                   with only FWB PB cal applied.
#    12apr18   nv   Make dolinecal=1 default; set csflag sarray=0 (swept vol)
#    12jul25   nv   Run csflag twice, once for same subarray, once for others.
#    12aug01   nv   Add uvbflag options=astats, to display bitmask, per ant.
#    12oct22   pjt  gpplt and using options=absent
#    12oct23   nv   Two gs and one pdftk to get all pages into same orientation.
#    12dec12   nv   Organize reports by ISO date standard: YYYY-MM-DD 
#    13feb27   nv   create datatype 5 for CARMA23@1cm datasets; drop USB data.
#                   Set defaults dolinecal=0, docontmap=y.
#    13apr24   nv   For datatype 2, uvflag WB corr band7, bsln 16-17
#    13may10   nv   Add options=all to smavarplt for rmspath, tau230 data.
#    13jul25   pjt  force tcsh since if (-X psselect) is used; added offsite fix
#                   A few cleanups in case quality is re-run, fix csh typo
#                   options=absent doesn't work on gpcopy mode=create datasets.
#    13aug20   pjt  w/ fixed gpplt now back to using gpplt (smagpplt cannot deal
#                   with mode=create datasets either)
#    13sep19   nv   use uvlist/uvio to determine which corr was used.
#                   Separate identification of corr, subarray, and array type.
#    13nov12   pjt  (aka 11/12/13) add bfmask processing
#    13nov20   tw   renumber datatypes; fixes for new gpplt; don't eliminate
#                   autocorrs (causing 0 durations in listobs); bpph2.ps plot;
#                   re-enable options=compress; sources not required;
#                   use gaincal for passband if no passcal specified
#    14mar12   nv   post-CentOS6: pdftk output (endR->end) for landscape plots.
#                   Add flagging for WB corr birdies (lines 680-681).
#    14mar28   pjt  Add /opt/carmaTools/bin/ to $path to get the right python
#                   for bfmask/python processing
#                   Also resurrent the optional offsite= keyword to run MIS at
#                   the site and pretend to be offsite
#    14apr15   nv   datatype 6 has only LSB. Drop USB for systemp display.
#_____________________________________________________________________________

set startTimeInSec = `date +%s`
set ndc="[Carma quality script]"
set YEAR=`/bin/date +%Y`
set scriptname=`echo $0 | sed 's/-//g'`
set name="carma.scripts.`basename $scriptname`"
set level="INFO"
set logmsg="{$YEAR} {$level} {$name} {$ndc} $scriptname Started `date` by $USER on `hostname`"
echo "$logmsg"
logger -p "LOCAL2.INFO" "$logmsg"


# check of <ctrl-c> aborts and try to cleanup. Note, this gets reset later
# to onintr finish but that is what <ctrl-c> is meant to do.
onintr abortcln

# set up alias to allow basic maths commands
alias MATH 'set \!:1 = `echo "\!:3-$" | bc -l`'        

set version=20140415
echo ""
echo "Running quality version $version"
echo ""

# Required parameters (otherwise prompted)
set proj=
set sources=
set gaincals=
set passcals=
set fluxcal=

# Optional user parameters to enter on command line
set see=n                # Display the plots onscreen?
set prn=n                # Print the plots immediately?
# Which spectral window to use for gain calibration.  Defaults to 1st widest.
set banduse=
# Value of 1mm opacity at zenith to override value in data file
set tau230=
# Reference antenna to override default
set refant=
# Make a single continuum image? (default=y for SZA)
set docontmap=y

# Default parameters (user can override on command line)
set pdb=y                # Default is to update pdb
set c15refant=9          # Default CARMA-15 ref antenna
set c23refant=9          # Default CARMA-23 ref antenna
set szarefant=21         # Default SZA ref antenna
set dcorsolint=5         # Selfcal interval (mins) to estimate decorrelation
set bpsolint=1           # Selfcal interval (mins) for bandpass solution
set ampgainsolint=5      # Selfcal interval (mins) to estimate antenna gains
set tmax=1000            # Max for 2nd set of Tsys plots
set mselfcal=1           # Use Mike Regan's version of selfcal (1=true)
set smavarplt=1          # Use SMA version of varplt for tsys.ps (1=true)
set dolinecal=0          # Apply the linelength phases to data (1=true)
set edgeflag=2           # Number of edge channels to flag when imaging
set tsysflag=5000        # Flag Tsys values larger than this
set ref3mm=112           # Fiducial frequency for 3mm grading. 0 => use LO1
set ref1mm=230           # Fiducial frequency for 1mm grading. 0 => use LO1
set ref1cm=30            # Fiducial frequency for 1cm grading. 0 => use LO1
set uvaver=0             # Averaging interval in minutes. 0 => no averaging
unset offsite            # by setting offsite=1 you can force using it in MIS 
set pacs=n               # Switch for PACS mode

#------------------------ CHECK INPUTS  -----------------------------------

alias skip 'echo ""; echo "&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&"'

# If at CARMA, set up directory structure
echo "WARNING - HARDWIRED CONF DIRECTORY"
set CONFDIR = "/opt/rt/conf/sdp"
set CONFFILE = "${CONFDIR}/sdp.conf"
if (-e $CONFFILE) then
    echo "ON SITE"
    set TOP=`awk '{if ($1 =="top") print $3}' $CONFFILE`
    set SDP=`awk '{if ($1 =="sdp") {split($3,a,"/") ; print a[2]}}' $CONFFILE`
    set SCID=`awk '{if ($1 =="scienceDataFormatDir") {split($3,a,"/") ; print a[2]}}' $CONFFILE`
    set QDIR=`awk '{if ($1 =="qualityDir") {split($3,a,"/") ; print a[2]}}' $CONFFILE`
    set DATADIR="$TOP/$SDP/$SCID"  # usually /opt/sdp/sciencedata
    set REPORTS="$TOP/$SDP/$QDIR"  # usually /opt/sdp/quality
    set SCRATCH="/tmp/$QDIR"       # usually /tmp/quality
    set USERSYNC=`awk '{if ($1 =="useRsync") print $3}' $CONFFILE`
    set REMOTEHOST=`awk '{if ($1 =="remoteHost") print $3}' $CONFFILE`
else
    echo "WARNING: Unable to find directory structure in $CONFFILE"
    echo "Assuming you are running off-site"
    set DATADIR=`pwd`
    set SCRATCH=`pwd`/quality
    set REPORTS=
    set pdb=n
    set USERSYNC="no"
endif

#  onsite add proper python to the $PATH (needs pyfits and numpy)
if (-d /opt/carmaTools/bin) then
  echo Adding /opt/carmaTools/bin for proper python
  set path=(/opt/carmaTools/bin $path)
  rehash
endif

# Override above parameters if given on the command line
foreach a ( $* )
   set check=`echo $a | awk -F= '{print NF}'`
   if ( "$check" == 2 ) set $a
end

# Double check if the hidden parameter offsite=1 was used
if ($?offsite) then
  if ($?offsite == 1) then
    echo "WARNING: Unable to find directory structure in $CONFFILE"
    echo "Assuming you are running off-site"
    set DATADIR=`pwd`
    set SCRATCH=`pwd`/quality
    set REPORTS=
    set pdb=n
    set USERSYNC="no"
  endif
endif

# Make sure the directories are defined
if ($?SCRATCH == 0 || $?DATADIR == 0) then
    echo "*** FATAL: DATADIR= and SCRATCH= keywords must be specified."
    exit 0
endif

# Make sure the data directory exists
if !(-e $DATADIR) then
    echo "*** FATAL: DATADIR directory $DATADIR not found"
    exit 0
endif

# if USERSYNC is set to yes, then check to see if remote host is alive
if ("$USERSYNC" == 'yes') then
   ping -q -c 2 $REMOTEHOST >& /dev/null
if ($? != 0) then
   echo -n "You have selected to use rsync, but the remote host: $REMOTEHOST"
   echo " cannot be reached. Bye"
   goto abortcln
endif
endif
# Allow substitute routines
if ($?meanmed) then
    alias meanmed $meanmed
endif
if ($mselfcal == 1) alias selfcal mselfcal
if ($smavarplt == 1) then
    alias svarplt smavarplt
else
    alias svarplt varplt
endif

# Generate filenames and directory structure
if ($proj == '') then
    if ($#argv >= 1) then
        set proj=$1
    else
        echo "*** FATAL: proj= keyword must be specified."
        goto abortcln
    endif
endif
set proj=`echo $proj | sed 's/\/$//'`
set proj=$proj:t
if ($proj:e == 'mir' || $proj:e == 'miriad') then
    set root = $proj:r
    set infile = $proj
else
    set root = $proj
    set infile = $proj.mir
endif
set mirfile=$root.qual
set logfile=$root.qq.log

# project name will be in format: prjtag.obsBlock.mir
set prjtag = `echo $proj | cut -d . -f1`
set obstag = `echo $root | cut -d . -f2-4`
umask 0
if !(-e $SCRATCH/$prjtag/$obstag) mkdir -p $SCRATCH/$prjtag/$obstag
if (-e $SCRATCH/$prjtag/$obstag) then
    cd $SCRATCH/$prjtag/$obstag
    echo "Working in directory $SCRATCH/$prjtag/$obstag"
else
    echo "*** FATAL: $SCRATCH/$prjtag/$obstag could not be created. ***"
    goto abortcln
endif
echo ""

#------------------------ DATA TRANSFER BLOCK -----------------------------
# 2011.12.12 rh: transfer original data using rsync to bypass slow NFS
#                USERSYNC and REMOTEHOST defined in config file
if ("$USERSYNC" == 'yes') then
   set remoteFile = ""
   set UNTAR_CMD = "echo ''"
   if (-e $DATADIR/$infile) then
      set remoteFile = $DATADIR/$infile
   else if (-e $DATADIR/$infile.tar.gz) then 
      set remoteFile = $DATADIR/$infile.tar.gz
      set UNTAR_CMD = "tar -xzf $infile.tar.gz"
   else
      echo "*** FATAL: project file not found ***" 
      goto abortcln
   endif
   echo "Using rsync to transfer data from ${REMOTEHOST}:${remoteFile} to $SCRATCH/$prjtag/$obstag/"
#  We cd'd into the $SCRATCH/$prjtag/$obstag directory so all operations are
#  local
   rsync --progress -a -e ssh ${REMOTEHOST}:${remoteFile} .
   $UNTAR_CMD
   set DATADIR="$SCRATCH/$prjtag/$obstag" 
else
   if !(-e $DATADIR/$infile) then
      if !(-e $DATADIR/$infile.tar.gz) then 
         echo "*** FATAL: project file not found ***" 
         goto abortcln
      else 
         echo "miriad file $DATADIR/$infile.tar.gz found. Extracting the data..." 
#        if $DATADIR is NFS mounted, performance may suffer. In which case
#        set USERSYNC = yes in the config file as well as the remote host.
         tar -xzvf $DATADIR/$infile.tar.gz
         set DATADIR="$SCRATCH/$prjtag/$obstag" 
      endif
   endif 
endif # end if usersync

echo "Data transfer completed. Data directory being set to: $DATADIR"

#------------------------ SUBARRAY BLOCK ----------------------------------
# Makes various choices based on the current subarray.

skip;echo "*** Copying data and identifying data type"

# Copy the cross-correlation data, applying time averaging if requested
# With time averaging, degenerate windows with 0 channels are discarded
rm -rf uvfile.mir
if ($uvaver != '0') then
    uvaver vis=$DATADIR/$infile out=uvfile.mir interval=$uvaver # select='-auto'
else
    uvcat vis=$DATADIR/$infile out=uvfile.mir # select='-auto'
endif
prthd in=uvfile.mir > tmp.prthd

# Run listobs to identify the observing frequency and antennas
listobs vis=uvfile.mir log=listobs1
set lofreq=`awk '/First LO/ {print $10}' listobs1`
set nlofreq = `echo "$lofreq" | awk '{printf("%d",$1)}'`
set antslin=`awk '/Sys Temps/ {print NR+1}' listobs1`
set ants=`sed -n "${antslin}p" listobs1 | sed 's/\(.*[deg,mode]\)//'`
echo "Antennas present: $ants"
set chanperband=`uvlist vis=uvfile.mir options=var,full | grep nschan | head -1 | awk '{print $NF}'`
set modedesc=`uvio vis=uvfile.mir | grep modedesc | tail -1 | awk '{print $4}' | grep -c b`

# identify which correlator
if ($chanperband == 15 && $modedesc == 0) then
    set corr = 'WB'
else
    set corr = 'SL'
endif
echo ""
echo "Correlator type: $corr"

# Identify the (sub)array
if ($corr == 'WB') then
    set subarray = 2
else if ($corr == 'SL') then
    set subarray = 1
endif
echo ""
echo "Subarray number: $subarray"

# Identify the number of ants
if ($ants[1] > 15) then   # the lowest number ant is >15; must be 3.5m only
    set array = 'CARMA-3.5m'
else if ($ants[$#ants] > 15) then # the highest number ant is >15; must be CARMA23
    set array = 'CARMA23'
else # must be CARMA15
    set array = 'CARMA15'
endif
echo ""
echo "Configuration type: $array"

# Set the data type
# 1 = CARMA15, 3mm/1mm mode
# 2 = SZA, 1cm LSB mode
# 3 = SZA, 3mm USB mode
# 4 = CARMA23, 3mm USB mode
# 5 = CARMA23, 1cm LSB mode
# 6 = CARMA15, 1cm mode
if ($array == 'CARMA15') then
    if ($nlofreq < 60) then
        set datatype = 6 # was 2
        echo "10m+6m antennas: cm mode"
        set tmax=300
    else
        set datatype = 1 # was 3
        echo "10m+6m antennas: mm mode"
    endif
    set nxy1='3,5'         # all antennas
    set nxygp='5,3'        # found antennas, gains(time)
    set nxybp='3,5'        # found antennas, bandpass
endif
if ($array == 'CARMA23') then
    if ($nlofreq > 60) then
        set datatype = 4 # was 1
        echo "10m+6m+3.5m antennas: 3mm USB mode"
    else
        set datatype = 5
        echo "10m+6m+3.5m antennas: 1cm LSB mode"
        set tmax=300
    endif
    set nxy1='4,6'
    set nxygp='6,4'
    set nxybp='4,6'
endif
if ($array == 'CARMA-3.5m') then
    if ($nlofreq > 60) then
        set datatype = 3 # was 4
        echo "3.5m antennas: 3mm USB Mode"
    else
        set datatype = 2
        echo "3.5m antennas: 1cm LSB Mode"
        set tmax=150
    endif
    set nxy1='4,6'
    set nxygp='4,2'
    set nxybp='3,3'
    set docontmap=y
endif
echo "Data type code: $datatype"

# Remove any spectral windows with zero channels
set li=`awk '/Spectrum/ {print NR+1}' tmp.prthd`
set lf=`awk '/channels/ {print NR-1}' tmp.prthd`
set drop=`sed -n "$li,${lf}p" tmp.prthd | awk '{if ($2==0) print $1}'`
# For arrays incl. 3.5m dishes we also need to toss out one sideband
# We drop the USB for 1cm data and the LSB for 3mm data
set lsb=`sed -n "$li,${lf}p" tmp.prthd | awk -v lo=$lofreq '{if ($3<lo) print $1}'`
set usb=`sed -n "$li,${lf}p" tmp.prthd | awk -v lo=$lofreq '{if ($3>lo) print $1}'`
if ($datatype == 2 || $datatype == 5) then
    set drop=($drop $usb)
else if ($datatype == 6) then
    set drop=($drop $usb)
endif
if ($datatype == 3 || $datatype == 4) set drop=($drop $lsb)
set drop2=`echo $drop | sed 's/ /\n/g' | sort -n | uniq`
set flag=`echo $drop2 | sed 's/ /,/g'`
if ($flag != "") then
    echo "Discarding windows $flag"
    uvcat vis=uvfile.mir select="-win($flag)" out=winsel.mir options=nowide
    rm -rf uvfile.mir
    mv winsel.mir uvfile.mir
endif

# Choose the reference antenna
if ($refant == '') then
    if ($array == 'CARMA-3.5m') set refant=$szarefant
    if ($array == 'CARMA15') set refant=$c15refant
    if ($array == 'CARMA23') set refant=$c23refant
endif

# Choose a new reference antenna if default is unavailable
set reffound = 0
foreach ant ($ants)
    if ($refant == $ant) then
        set reffound = 1
    endif
end
if ($reffound == 0) then
    echo "*** WARNING: Requested reference antenna $refant not found"
    set refant = $ants[1]
    echo "Using antenna $ants[1] instead"
endif


#------------------------ LISTOBS BLOCK ----------------------------------
# Provides an observations summary and classifies the observed targets.

skip;echo "*** Listing the data"

# Re-generate the wideband channels if necessary
uvlist vis=uvfile.mir options=var,full log=tmp.uvlist
set nspect=`grep nspect tmp.uvlist | sed 's/.*nspect[ ]*://' | awk '{print $1}'`
set npol=`grep npol tmp.uvlist | sed 's/.*npol[ ]*://' | awk '{print $1}'`
set pol1=`grep Polar tmp.prthd | sed 's/.*://' | sed 's/,/ /' | awk '{print $1}'`
if ("`itemize in=uvfile.mir/vartable | grep nwide`" == '') then
    echo "Re-creating $nspect wideband windows"
    rm -rf uvwide.mir
    uvwide vis=uvfile.mir out=uvwide.mir nwide=$nspect
    set usefile=uvwide.mir
else
    set usefile=uvfile.mir
endif

# Separate out NOISE integrations, which confuse plots
rm -rf $mirfile noise.mir
uvcat vis=$usefile select='-source(NOISE)' out=$mirfile
uvcat vis=$usefile select='source(NOISE)' out=noise.mir

# Get the number of NOISE integrations from the full listobs
set beglin=`awk '/Sys Temps/ {print NR+2}' listobs1`
set endlin=`wc listobs1 | awk '{print $1-1}'`
sed -n "$beglin,${endlin}p" listobs1 > listobs.tab
set nnoise=`grep NOISE listobs.tab | wc | awk '{print $1}'`

# Get the date and frequency
set CalDate=`awk '/Chronology/ {print $5}' listobs1`
set lofreq=`awk '/First LO/ {print $10}' listobs1`
set restfreq=`awk '/Rest Freq/ {print $6}' listobs1`

echo "+++++++++++++++++++++"
echo "LO: $lofreq GHz"
echo "RestFreq: $restfreq GHz"
echo "---------------------"

# Begin writing the logfile
echo "PROJECT=$proj  DATE=$CalDate  Q_RUN_TIME($HOST,v.$version)=`date`" >> $logfile
echo -n '---------------------------------------------' >> $logfile
echo    '---------------------------------------------' >> $logfile

# Run listobs again without NOISE integrations
listobs vis=$mirfile log=listobs2

# Include the listobs output
set beglin=`awk '/Sys Temps/ {print NR}' listobs2`
sed -n "${beglin}p" listobs2 | sed "s/(K)/& near $lofreq GHz (LO1)/" >> $logfile
@ beglin ++
set endlin=`wc listobs2 | awk '{print $1-1}'`
sed -n "$beglin,${endlin}p" listobs2 >> $logfile

# Get the maximum and median baseline length
set lambda=`calc -f f8.6 "0.3/$lofreq"` # meters
grep Bsln listobs2 | sed 's/\(.*:\)//' | awk '{printf "%d\n", sqrt($1^2 + $2^2 + $3^2)}' \
    >! bsln.out
set maxbsln=`sort -n bsln.out | tail -1`
set medbsln=`cat bsln.out | sort -n | awk '{arr[NR]=$1} END {if (NR%2==1) print arr[(NR+1)/2]; else print (arr[NR/2]+arr[NR/2+1])/2}'`
set baselen=`calc -f f8.2 "$lambda*$maxbsln"`
# If there is no passcal, choose the first gaincal:

# Get the source list and their intents
set beglin2=`awk '/Observed Sources/ {print NR+2}' listobs2`
set endlin2=`awk '/Frequency Set-up/ {print NR-2}' listobs2`
set allobs=`sed -n "$beglin2,${endlin2}p" listobs2 | awk '{print $1}'`
set purpose=`sed -n "$beglin2,${endlin2}p" listobs2 | awk '{print $2}'`
set i=1
set defsources=
set defgaincals=
set defpasscals=
set deffluxcal=
echo "" | tee -a $logfile
while ($i <= $#allobs)
    if ($purpose[$i] =~ *B*) set defpasscals = ($defpasscals $allobs[$i])
    if ($purpose[$i] =~ *G*) set defgaincals = ($defgaincals $allobs[$i])
    if ($purpose[$i] =~ *S*) set defsources = ($defsources $allobs[$i])
    if ($purpose[$i] =~ *F*) set deffluxcal = ($deffluxcal $allobs[$i])
    if ($purpose[$i] =~ *A*) set defsources = ($defsources $allobs[$i])
    if ($purpose[$i] =~ *O*) set defgaincals = ($defgaincals $allobs[$i])
    echo "Source $allobs[$i] has purpose $purpose[$i]" | tee -a $logfile
    set i = `expr $i + 1`
end

# If there are 2 or more passcals, remove any planets:
if ($#defpasscals > 1) then
    foreach passcal ($defpasscals)
        if ($passcal =~ {MERCURY,VENUS,MARS,JUPITER,SATURN,URANUS,NEPTUNE,MWC349}) then
            if ($#defpasscals > 1) then
                set defpasscals=`echo $defpasscals | sed "s/$passcal//"`
            endif
        endif
    end
endif

# If there are 2 or more gaincals, remove any planets:
if ($#defgaincals > 1) then
    foreach gaincal ($defgaincals)
        if ($gaincal =~ {MERCURY,VENUS,MARS,JUPITER,SATURN,URANUS,NEPTUNE,MWC349}) then
            if ($#defgaincals > 1) then
                set defgaincals=`echo $defgaincals | sed "s/$gaincal//"`
            endif
        endif
    end
endif

# If there are 2 or more fluxcals, choose a planet:
if ($#deffluxcal > 1) then
    foreach obj ($deffluxcal)
        if ($obj !~ {MERCURY,VENUS,MARS,JUPITER,SATURN,URANUS,NEPTUNE,MWC349}) then
            if ($#deffluxcal > 1) then
                set deffluxcal=`echo $deffluxcal | sed "s/$obj//"`
            endif
        endif
    end
    if ($#deffluxcal > 1) set deffluxcal=$deffluxcal[1]
endif

# State the default classifications
echo ""
echo "Default assignments, based on source intent:"
echo "sources : $defsources"
echo "gaincals: $defgaincals"
echo "passcals: $defpasscals"
echo "fluxcal: $deffluxcal"

# Prompt for override if we're running without command-line arguments
echo "Note: at least one gaincal is required"
echo "PAUSING FOR 10 SEC; TYPE CTRL-C TO OVERRIDE THESE CHOICES..."  
onintr srcreq
sleep 10

if ($sources == '') set sources=`echo $defsources | sed 's/ /,/g'`
if ($gaincals == '') set gaincals=`echo $defgaincals | sed 's/ /,/g'`
if ($passcals == '') set passcals=`echo $defpasscals | sed 's/ /,/g'`
# If there is no passcal, choose the first gaincal:
if ($passcals == '') set passcals=$defgaincals[1]
if ($fluxcal == '') set fluxcal=$deffluxcal
goto srclist

srcreq:
onintr abortcln

echo ""
echo -n "Enter names of program sources, comma-separated: "
set sources=`echo "$<" | sed 's/ //g'`
echo -n "Enter names of gaincals, comma-separated (REQUIRED): "
set gaincals=`echo "$<" | sed 's/ //g'`
echo -n "Enter names of passcals, comma-separated (OK to repeat gaincal names): "
set passcals=`echo "$<" | sed 's/ //g'`
echo -n "Enter name of the fluxcal (blank if none): "
set fluxcal="$<"

srclist:
onintr abortcln

# Compile lists of sources
set sourcelis=`echo "$sources" | sed 's/,/ /g'`
set gaincalis=`echo "$gaincals" | sed 's/,/ /g'`
set passcalis=`echo "$passcals" | sed 's/,/ /g'`
set allcals = ()
set allobjs = ()
foreach obj ($gaincalis $passcalis $fluxcal)
    set val=`echo $allcals | grep $obj`
    if ("$val" == "") set allcals = ($obj $allcals)
end
foreach obj ($sourcelis $gaincalis $passcalis $fluxcal)
    set val=`echo $allobjs | grep $obj`
    if ("$val" == "") set allobjs = ($obj $allobjs)
end

# Announce object classification
echo "" | tee -a $logfile
echo "sources : $sources" | tee -a $logfile
echo "gaincals: $gaincals" | tee -a $logfile
echo "passcals: $passcals" | tee -a $logfile
echo "fluxcal: $fluxcal" | tee -a $logfile

# Get the elapsed project time, note this includes NOISE integrations
head -1 listobs.tab > log1
tail -1 listobs.tab > log2
set starttime=`awk '{print $2}' log1`
set stoptime=`awk '{print $2}' log2`
set starthours=`echo $starttime | awk '{split ($1,h,""); print h[1] h[2]}'`
set startminutes=`echo $starttime | awk '{split ($1,h,""); print h[3] h[4]}'`
set stophours=`echo $stoptime | awk '{split ($1,h,""); print h[1] h[2]}'`
set stopminutes=`echo $stoptime | awk '{split ($1,h,""); print h[3] h[4]}'`
set addminutes=`awk '{print $4}' log2`

set starttime = `calc -f f6.3 "$starthours+$startminutes/60.0"`
set stoptime  = `calc -f f6.3 "$stophours+($stopminutes+$addminutes)/60.0"`
set stoptime  = `echo $starttime $stoptime | awk '{if ($1 > $2) print ($2 + 24); else print $2}'`
set totaltime = `calc -f f6.1 "$stoptime-$starttime"`
# Total time is reported in the OBSTIME block
rm -f log[1-2]

echo "There were $nnoise NOISE integrations" | tee -a $logfile
echo "Using $refant as the reference antenna" | tee -a $logfile
if ($uvaver != '0') then
    echo "Visibility data averaged over $uvaver minute interval" | tee -a $logfile
endif

#------------------------ SYSTEMP BLOCK ----------------------------------

skip;echo "*** Plotting weather variables and system temperatures"

# Make the weather plots
foreach var (rmspath tau230 precipmm)
    svarplt vis=$mirfile yaxis=$var log=$var.log device=$var.ps/cps \
        dotsize=10 options=all
end

if ($npol == 1) then
    svarplt vis=$mirfile yaxis=systemp nxy=$nxy1 device=tsys1.ps/cps \
        options=compress,all dotsize=3
    svarplt vis=$mirfile yaxis=systemp nxy=$nxy1 device=tsys2.ps/cps \
        yrange=0,$tmax options=compress,all dotsize=3
else
    svarplt vis=$mirfile yaxis=xtsys nxy=$nxy1 device=tsys1.ps/cps \
        options=compress,all dotsize=3
    svarplt vis=$mirfile yaxis=ytsys nxy=$nxy1 device=tsys2.ps/cps \
        options=compress,all dotsize=3
    svarplt vis=$mirfile yaxis=xtsys nxy=$nxy1 device=tsys3.ps/cps \
        yrange=0,$tmax options=compress,all dotsize=3
    svarplt vis=$mirfile yaxis=ytsys nxy=$nxy1 device=tsys4.ps/cps \
        yrange=0,$tmax options=compress,all dotsize=3
endif

if (-X psselect) then
    foreach file (tsys*.ps)
        psselect -p1 $file tmp.ps
        mv tmp.ps $file
    end
endif

if ($see == 'y') then
    gv rmspath.ps &
    gv tau230.ps &
    gv tsys1.ps &
endif

#--------------------------- FLAGGING BLOCK -------------------------------

# run uvbflag with options=astats to display bit mask, per ant
#   then process the output a bit more for humans to read
#   this creates bfmask.ps and bfmask.txt
uvbflag vis=$DATADIR/$infile options=astats > tmp.uvbflag
bfmask_astats.py tmp.uvbflag
echo "uvbflag (options=astat):" | tee -a $logfile
if (-e bfmask.txt) then
   cat bfmask.txt | tee -a $logfile
else
   tail -34 tmp.uvbflag >> $logfile
endif

skip;echo "*** Flagging shadowed data"

#with sarray unset, flags are for same subarray
csflag vis=$mirfile carma=True > tmp.csflag_same
echo -n "csflag (same subarray):" | tee -a $logfile
tail -1 tmp.csflag_same | tee -a $logfile
#with sarray=0, flags are for all antennas NOT in subarray
csflag vis=$mirfile carma=True sarray=0 > tmp.csflag_other
echo -n "csflag (other subarrays):" | tee -a $logfile
tail -1 tmp.csflag_other | tee -a $logfile

skip;echo "*** Flagging Tsys > $tsysflag"

uvflag vis=uvfile.mir flagval=f tsys=$tsysflag > tmp.uvflag
echo "Flagging Tsys values > $tsysflag" | tee -a $logfile
set li=`awk '/Orig/ {print NR}' tmp.uvflag`
set lf=`awk '/Bad/ {print NR}' tmp.uvflag`
sed -n "$li[1],$lf[1]p" tmp.uvflag | tee -a $logfile

skip;echo "*** Flagging WB corr birdies"

if ($datatype == 2) then
    #uvflag vis=$mirfile flagval=flag select="win(7),ant(16)(17)"
    #uvflag vis=$mirfile flagval=flag select="win(7),ant(16)(21)"
endif

#--------------------------- LINECAL BLOCK -------------------------------

skip;echo "*** Plotting the linelength phases"

rm -rf linecal.gains
linecal vis=$mirfile out=linecal.gains
gpplt vis=linecal.gains yaxis=phase yrange=-180,180 options=wrap \
    device=linecal.ps/ps nxy=$nxy1
if ( $dolinecal != 0 ) then
    gpcopy vis=linecal.gains out=$mirfile
endif
if (-X psselect) then
    psselect -p1 linecal.ps tmp.ps
    mv tmp.ps linecal.ps
endif
if ($see == 'y') then
    gv linecal.ps &
endif

#--------------------------- OBSTIME BLOCK--------------------------------

skip;echo "*** Evaluating observing time statistics"

echo "" | tee -a $logfile
echo "Total project time $totaltime hrs from start to finish" | tee -a $logfile

# Split the data in order to get time on each source
set timesum=0
foreach obj ($allobjs)
    rm -rf $obj
    uvcat vis=$mirfile out=$obj select="source($obj),-auto" options=unflagged
    uvindex vis=$obj log=tmp.uvindex
    set term=`grep "Total observing time" tmp.uvindex | awk '{print $5}'`
    echo "Total observe time $term hrs for $obj" | tee -a $logfile
    set timesum=`echo "$timesum+$term" | bc -l`
end
echo "Total observe time $timesum hrs for entire track" | tee -a $logfile

#--------------------------- UVDISTANCE BLOCK------------------------------
# Plot calibrated phases vs. uv-distance.
# Calibrates the gaincal data and estimates decorrelation over 5 mins.

skip;echo "*** Plotting calibrated phase vs. uvdistance"

if ($gaincals == "") then
    echo "" | tee -a $logfile
    echo "*** FATAL ERROR: no gaincal; quality aborting!" | tee -a $logfile
    echo "DEFAULT GRADE: F" | tee -a $logfile
    set grade=F
    set pdb=n
    goto cleanup
endif

# Merge the gain calibrators into a single dataset
rm -rf gaincals.mir
uvcat vis=$mirfile select="source($gaincals),-auto" options=nopol,nopass \
    out=gaincals.mir

# Determine the correlator setup on gain calibrators
prthd in=gaincals.mir log=tmp.prthd 
set beglin=`awk '/Bandwidth/ {print NR+1}' tmp.prthd`
set endlin=`awk '/J2000/ {print NR-3}' tmp.prthd`
sed -n "$beglin,${endlin}p" tmp.prthd > tmp.corr1
set corrno = `cat tmp.corr1 | awk '{print $1}'`
set corfreq = `cat tmp.corr1 | awk '{print $2}'`
set bandwcal = `cat tmp.corr1 | awk '{printf "%5d", 1000*sqrt($3*$3)}'`

# Determine the correlator setup on sources
if ($sources != "") then
    prthd in=$sourcelis[1] log=tmp.prthd 
    set beglin=`awk '/Bandwidth/ {print NR+1}' tmp.prthd`
    set endlin=`awk '/J2000/ {print NR-3}' tmp.prthd`
    sed -n "$beglin,${endlin}p" tmp.prthd > tmp.corr2
    set srcfreq = `cat tmp.corr2 | awk '{print $2}'`
    set bandwsrc = `cat tmp.corr2 | awk '{printf "%5d", 1000*sqrt($3*$3)}'`
endif

# Output information about the correlator setup
echo "" | tee -a $logfile
echo "-"
if ($datatype == 3 || $datatype == 4) then
    echo "**Only USB data processed**" | tee -a $logfile
else if ($datatype == 2 || $datatype == 5) then
    echo "**Only LSB data processed**" | tee -a $logfile
else if ($datatype == 6) then
    echo "**Only LSB data processed**" | tee -a $logfile
else
    echo "**10m+6m Data**" | tee -a $logfile
endif
echo "-"

echo "Correlator setup for gain calibrators:" | tee -a $logfile
cat tmp.corr1 | tee -a $logfile
#echo "Correlator setup for sources:" | tee -a $logfile
#cat tmp.corr2 | tee -a $logfile

# Get the first 500 MHz window on phasecal, otherwise just use largest bw
if ("$banduse" != "") then
    set buse=$banduse
    goto setbeuse
endif
set maxbw = 0
foreach i ($corrno)
    if (`echo $bandwcal[$i] | awk '{print ($1>400)}'` == 1) then
        set buse = $i
        goto setbeuse
    else if (`echo $bandwcal[$i] $maxbw | awk '{print ($1>$2)}'` == 1) then
        set buse = $i
        set maxbw = $bandwcal[$i]
    endif
end
setbeuse:
echo "Using window $buse, BW $bandwcal[$buse] MHz for gain calibration" \
    | tee -a $logfile

# Calibrate the phase only using a 5 minute solution interval.
selfcal vis=gaincals.mir line=wide,1,$buse select="pol($pol1)" \
    interval=$dcorsolint refant=$refant options=phase

# Plot the calibrated phase vs uv-distance.
uvplt vis=gaincals.mir axis=uvd,phase nxy=1,1 options=nobase,2pass \
    device=uvphase.ps/ps yrange=-180,180 line=wide,1,$buse select="pol($pol1)" \
    inc=10 size=1,2
if ($see == 'y') then
    gv uvphase.ps &
endif

# Make an estimate of the time interval needed to obtain S/N ~ 8 on a 6m-6m
# baseline.  This will be used to determine the default gain solution interval.
# set snr=8
# 
# # Get the jyperk and median systemp on the reference antenna
# foreach var (systemp jyperka)
#     varplt vis=gaincals.mir yaxis=$var log=$var.log1 options=compress
#     sed -e :a -e '$\!N;s/\n  / /;ta' -e 'P;D' $var.log1 > $var.log2
#     set colno=`expr $refant + 2`
#     cat $var.log2 | grep -v '#' | awk '{print $s}' s=$colno | \
#         grep -v '[:alpha:]' > $var.log3
#     meanmed infile=$var.log3 | tee $var.log4
# end
# set mtsys = `tail -1 systemp.log4 | awk '{print $2}'`
# set jyperk = `tail -1 jyperka.log4 | awk '{print $2}'`
# 
# # Use the mean gaincal flux as the nominal flux value
# calred vis=gaincals.mir line=wide,1,$buse select="pol($pol1)" > calred.log
# set beglin=`awk '/Source/ {print NR+1}' calred.log`
# set flux=`sed -n "$beglin,999p" calred.log | awk '{s += $3} END {printf "%5.2f\n", 1e-3*s/NR}'`
# 
# # Get the default gain solution interval, quantized by 30s, bounded by 0.5 & 5 min
# set t30=`calc -i "($jyperk*$mtsys*$snr)**2/(30*2*$bandwcal[$buse]*1e6*$flux**2)"`
# if (`echo $t30 | awk '{print ($1<1)}'` == 1) then
#     set defgainsolint=0.5
# else if (`echo $t30 | awk '{print ($1>10)}'` == 1) then
#     set defgainsolint=5
# else
#     set defgainsolint=`calc -f f4.1 "$t30*0.5"`
# endif
# if ($ampgainsolint == 0) then
#     echo "Median T_sys for Ant $refant is $mtsys"  | tee -a $logfile
#     echo "Nominal Jy/K for Ant $refant is $jyperk" | tee -a $logfile
#     echo "Mean flux for gaincals is $flux pseudo-Jy" | tee -a $logfile
#     echo "Using flux-based gain solution interval of $defgainsolint min" \
#         | tee -a $logfile
#     set ampgainsolint=$defgainsolint
# else
#     echo "Using gain solution interval of $ampgainsolint min" \
#         | tee -a $logfile
# endif

# Estimate decorrelation ratio using the specified solution interval.
echo "" | tee -a $logfile
echo "*******************************************************************" | \
tee -a $logfile
echo "decorrelation estimated from the ratio of vector to scalar averaged" | \
tee -a $logfile
echo "amplitudes following a phase-only selfcal with a $dcorsolint min interval." | \
tee -a $logfile
echo "" | tee -a $logfile
uvflux vis=gaincals.mir line=wide,1,$buse select="pol($pol1)" >! tmp.uvflux
echo "  source       vec_avg    phase_coherence" | tee -a $logfile
echo "----------     -------    ---------------" | tee -a $logfile
egrep '(E-|E+)' tmp.uvflux | \
awk '{printf "%10s %10.2f %15.2f\n", $1, $4, $4/$7}' | tee -a $logfile

#------------------------------ PASSBAND BLOCK ------------------------------
# Calibrates the bandpass and analyzes bandpass calibrator.

skip;echo "*** Calibrating the bandpass"

# Skip this if no passband calibrators.
if ( "$passcals" == "" ) then
    set nopasscals=1
    goto flux
else
    set nopasscals=0
endif

# Select the appropriate passband data.
rm -rf passcals.mir passcals.$buse.mir
uvcat vis=$mirfile select="source($passcals)" options=nopol,nopass \
    out=passcals.mir
uvcat vis=$mirfile select="source($passcals),win($buse)" options=nopol,nopass \
    out=passcals.$buse.mir

# Compute the passband solutions and plot.
mfcal vis=passcals.mir interval=$bpsolint refant=$refant edge=$edgeflag
mfcal vis=passcals.$buse.mir interval=$bpsolint refant=$refant edge=$edgeflag
gpplt vis=passcals.mir options=bandpass,absent device=bpamp.ps/cps \
    yrange=0,2 nxy=$nxybp 
gpplt vis=passcals.mir options=bandpass,wrap,absent device=bpph.ps/cps \
    yaxis=phase yrange=-180,180 nxy=$nxybp 
if ($see == 'y') then
    gv bpamp.ps &
    gv bpph.ps &
endif
if ($corr == 'SL') then
  smagpplt vis=passcals.mir options=bandpass,wrap,nofit device=bpph2.ps/cps \
    xaxis=chan yaxis=phase yrange=-180,180 nxy=$nxybp filelabel=1
endif
if ($see == 'y') then
    gv bpph2.ps &
endif

# Plot the noise solutions too.
# rm -rf noise2.mir
# uvcal vis=noise.mir out=noise2.mir options=noisecal
# mfcal vis=noise2.mir interval=9999 refant=$refant edge=$edgeflag
# smagpplt vis=noise2.mir options=bandpass,nofit device=bpnoise.ps/cps \
#     xaxis=chan yrange=0,2 nxy=$nxybp filelabel=1
# if !(-e bpnoise.ps) echo '*** WARNING: Noise source may be missing ***' \
#     | tee -a $logfile
# if (-X psselect) then
#     psselect -p1 bpnoise.ps tmp.ps
#     mv tmp.ps bpnoise.ps
# endif
# if ($see == 'y') then
#     gv bpnoise.ps &
# endif

# Estimate decorrelation ratio.
selfcal vis=passcals.mir line=wide,1,$buse select="pol($pol1)" interval=$dcorsolint \
    refant=$refant options=phase
uvflux vis=passcals.mir line=wide,1,$buse select="pol($pol1)" \
    options=nopass >! tmp.uvflux
egrep '(E-|E+)' tmp.uvflux | \
    awk '{printf "%10s %10.2f %15.2f\n",$1,$4,$4/$7}' > tmp.uvflux2
foreach gcal ($gaincalis)
    grep -v $gcal tmp.uvflux2 > tmp.uvflux
    mv tmp.uvflux tmp.uvflux2
end
cat tmp.uvflux2 | tee -a $logfile

#----------------------------- FLUXCAL BLOCK -------------------------------
flux:

skip;echo "*** Examining flux calibrator"

# Estimate decorrelation ratio
if ($fluxcal != '') then
    selfcal vis=$fluxcal options=phase select="pol($pol1)" \
        line=wide,1,$buse refant=$refant interval=$dcorsolint
    uvflux vis=$fluxcal line=wide,1,$buse select="pol($pol1)" >! tmp.uvflux
    egrep '(E-|E+)' tmp.uvflux | \
        awk '{printf "%10s %10.2f %15.2f\n",$1,$4,$4/$7}' > tmp.uvflux2
    foreach cal ($gaincalis $passcalis)
        grep -v $cal tmp.uvflux2 > tmp.uvflux
        mv tmp.uvflux tmp.uvflux2
    end
    cat tmp.uvflux2 | tee -a $logfile

# Output absolute amplitude gains
    echo "" | tee -a $logfile
    echo -n "Calibrated antenna gains from $fluxcal" | tee -a $logfile
    echo " (soln interval $ampgainsolint min)" | tee -a $logfile
    selfcal vis=$fluxcal options=apriori,amplitude,noscale \
        line=wide,1,$buse select="pol($pol1)" refant=$refant \
        interval=$ampgainsolint
    uvamp vis=$fluxcal line=wide,1,$buse select="pol($pol1)" device=fluxcal.ps/ps
    if ($see == 'y') then
        gv fluxcal.ps &
    endif
    gpaver vis=$fluxcal interval=1000 options=scalar
    gpplt vis=$fluxcal yaxis=amp log=ampgains.dat
    tail -n +5 ampgains.dat | tee -a $logfile
endif

#----------------------------- GAINS BLOCK -------------------------------
gains:

skip;echo "*** Calibrating the gains"

# Apply the bandpass to gain calibrators
if ($nopasscals == 0) then
    foreach cal ($gaincalis)
        rm -rf $cal.$buse
        uvcat vis=$cal out=$cal.$buse select="win($buse)"
        gpcopy vis=passcals.$buse.mir out=$cal.$buse options=nocal
        gpcopy vis=passcals.mir out=$cal options=nocal
        echo "Passband gains copied to $cal"
        uvlist vis=$cal options=var,full log=tmp.uvlist
        set delf=`grep sdf tmp.uvlist | tail -1 | sed 's/.*sdf[ ]*://' | awk '{print 1e3*sqrt($1**2)}'`
        set nchan=`grep nchan tmp.uvlist | sed 's/.*nchan[ ]*://' | awk '{print $1}'`
        set npass=`gethd in=$cal/nchan0`
        echo "nchan for data, bandpass: $nchan $npass"
        rm -rf $cal.cal $cal.$buse.cal
        uvcat vis=$cal out=$cal.cal
        uvcat vis=$cal.$buse out=$cal.$buse.cal
    end
    set ext=.$buse.cal
    #set ext=.cal
else
    set ext=.$buse
    #set ext=
endif

# Derive and plot gains(time) using a short solution interval
foreach cal ($gaincalis)
    selfcal vis=$cal$ext line=wide,1,$buse interval=$ampgainsolint \
        refant=$refant options=amplitude,apriori,noscale
    if ($cal != $gaincalis[1]) then
        gpcopy vis=$usefile out=$gaincalis[1]$ext mode=merge
    endif   
end
gpplt vis=$gaincalis[1]$ext nxy=$nxygp yaxis=amp yrange=0,5 \
    options=absent device=gns_amp.ps/ps
gpplt vis=$gaincalis[1]$ext nxy=$nxygp yaxis=phase yrange=-180,180 \
    options=wrap,absent device=gns_ph.ps/ps
if ($see == 'y') then
    gv gns_amp.ps &
    gv gns_ph.ps &
endif
rm -rf refant$refant.avgains
gpcopy vis=$gaincalis[1]$ext out=refant$refant.avgains mode=create
puthd in=$gaincalis[1]$ext/senmodel value='GSV' type=ascii
puthd in=$gaincalis[1]$ext/interval value=0.1 type=double

# Average the amplitude gains and report to logfile
gpaver vis=refant$refant.avgains interval=1000 options=scalar
gpplt vis=refant$refant.avgains yaxis=amp log=ampgains.dat
echo "" | tee -a $logfile
echo -n "Calibrated antenna gains from $gaincals" | tee -a $logfile
echo " (soln interval $ampgainsolint min)" | tee -a $logfile
tail -n +5 ampgains.dat | tee -a $logfile

# Use an OVRO antenna as reference; plot gains vs. time
# set ovrofound = 0
# foreach ant ($ants)
#     if ($ovrorefant == $ant) then
#         set ovrofound = 1
#     endif
# end
# if ($ovrofound == 1) then
#     rm -rf refant$ovrorefant.gains
#     foreach cal ($gaincalis)
#         selfcal vis=$cal line=wide,1,$buse interval=$ampgainsolint \
#             refant=$ovrorefant options=amplitude,apriori,noscale
#         if ($cal == $gaincalis[1]) then
#             gpcopy vis=$cal out=refant$ovrorefant.gains mode=create
#         else
#             gpcopy vis=$cal out=refant$ovrorefant.gains mode=merge
#         endif
#     end
#     gpplt vis=refant$ovrorefant.gains nxy=5,3 yaxis=phase yrange=-180,180 \
#         options=wrap device=ovrogns_ph.ps/ps
#     rm -rf refant$ovrorefant.mir
#     mv refant$refant.mir refant$ovrorefant.mir
#     selfcal vis=refant$ovrorefant.mir line=wide,1,$buse \
#        interval=$ampgainsolint refant=$ovrorefant options=amplitude,apriori,noscale
#     if ($see == 'y') then
#         gv ovrogns_ph.ps &
#      endif
# endif

#rm -rf refant$refant.mir refant$ovrorefant.mir
rm -f ampgains.dat

#----------------------------- IMAGE BLOCK -------------------------------
image:

skip;echo "*** Imaging the sources"

# Copy gains to sources and make images of each:
foreach src ($sourcelis)
    # The uvflag below is for WB corr cm data.
    if ($datatype == 2) then
        uvflag vis=$src flagval=flag select="win(7),ant(16)(17)"
    endif
    # Copy the bandpass gains
    echo " " | tee -a $logfile
    uvlist vis=$src options=spectra log=tmp.uvlist1
    set ch0=`grep 'starting chan' tmp.uvlist1 | sed 's/.*:[ ]*//'`
    set nch=`grep number tmp.uvlist1 | sed 's/.*:[ ]*//'`
    uvlist vis=$src options=var,full log=tmp.uvlist
    set totch=`grep nchan tmp.uvlist | sed 's/.*nchan[ ]*://' | awk '{print $1}'`
    if ($nopasscals == 0) then
        gpcopy vis=passcals.mir out=$src options=nocal
        echo "Passband gains copied to $src" | tee -a $logfile
    endif
    # Apply bandpass gains, copy gains
    rm -rf $src.cal
    uvcat vis=$src out=$src.cal
    gpcopy vis=$gaincalis[1]$ext out=$src.cal options=nopass
    set nspect=$#ch0
    # Loop through the spectral windows, generating maps.
    set i=1
    set im=1
    echo "colour 1" > $src.olay
    while ($i <= $nspect)
        set id=`printf "%02d" $i`
        rm -rf $src.$id.map
        set pow=`calc -i "1+log(1e4/$baselen/$lofreq)/log(2)"`
        set cell=`echo $pow | awk '{print 2**$1}'`
        if ($nlofreq < 60) then
            set imsize=`echo $pow | awk '{print 2**(10-$1)}'`
        else if ($nlofreq < 200) then
            set imsize=`echo $pow | awk '{print 2**(8-$1)}'`
        else
            set imsize=`echo $pow | awk '{print 2**(7-$1)}'`
        endif
        if ($imsize > 512) set imsize=512
        invert vis=$src.cal map=$src.$id.map imsize=$imsize \
            cell=$cell line=chan,1,$ch0[$i],$nch[$i] options=systemp,mosaic \
            robust=1 select="on(1)" | tee tmp.invert
        rm -rf $src.$id.sen $src.$id.gain
        mossen in=$src.$id.map sen=$src.$id.sen gain=$src.$id.gain
        rm -rf $src.$id.snr
        set minval=`histo in=$src.$id.sen | grep Min | awk '{printf "%3.1e",$3}'`
        maths exp="<$src.$id.map>/<$src.$id.sen>" out=$src.$id.snr
        if (-e $src.$id.snr) then
            echo "Window $id has theoretical rms $minval Jy at map center" \
                | tee -a $logfile
            set xpos=0
            set ypos=`gethd in=$src.$id.map/naxis2 | awk '{printf "%d",$1*0.88*0.25}'`
            echo -n "clear relpix relpix " >> $src.olay
            echo -n "$srcfreq[$i]_GHz/${bandwsrc[$i]}_MHz " >> $src.olay
            echo "yes $xpos $ypos $im $im" >> $src.olay
            set im=`expr $im + 1`
        else
            echo "ERROR: Window $id could not be imaged" | tee -a $logfile           
        endif
        rm -rf $src.$id.map
        set i=`expr $i + 1`
    end
    if ($nspect > 8) then
        set nxy2 = '4,4'
    else
        set nxy2 = '4,2'
    endif
    # Merge the maps (after noise normalization) and plot.
    rm -rf $src.snr $src.gain
    imcat in="$src.*.snr" out=$src.snr options=relax
    puthd in=$src.snr/bunit value='SIGMA'
    imcat in="$src.*.gain" out=$src.gain options=relax
    set max=`histo in=$src.snr | grep Max | awk '{printf "%d",$3+0.5}'`
    set min=`histo in=$src.snr | grep Min | awk '{printf "%d",$3+0.5}'`
    if ($max > 50) then
        cgdisp in=$src.snr,$src.gain type=p,c range=0,0,lin,3 \
        levs1=0.5 options=full,solneg1,black,wedge device=$src.map.ps/cps \
        labtyp=arcsec lines=2,2,2 csize=0.5,0,0.5 olay=$src.olay \
        region=quarter nxy=$nxy2 slev=a,1 cols1=0
    else
        cgdisp in=$src.snr,$src.snr,$src.gain type=p,c,c range=0,0,lin,3 \
        levs1=4 levs2=0.5 options=full,solneg2,black,wedge,mirr device=$src.map.ps/cps \
        labtyp=arcsec lines=2,1,2,2 csize=0.5,0,0.5 olay=$src.olay \
        region=quarter nxy=$nxy2 slev=a,1,a,1 cols1=4 cols2=0
    endif
    if ($see == 'y') then
        gv $src.map.ps &
    endif
    # Make a single continuum image.
    if ($docontmap == 'y') then
        rm -rf $src.cmap $src.csen $src.cgain $src.csnr
        invert vis=$src.cal map=$src.cmap imsize=$imsize \
            cell=$cell line=chan,1,1,$totch options=systemp,mosaic,mfs \
            robust=1 select="on(1)" | tee tmp.invert
        mossen in=$src.cmap sen=$src.csen gain=$src.cgain
        maths exp="<$src.cmap>/<$src.csen>" out=$src.csnr
        puthd in=$src.csnr/bunit value='SIGMA'
        cgdisp in=$src.csnr,$src.cgain type=p,c range=0,0,lin,3 \
            options=full,solneg1,black,wedge device=$src.cmap.ps/cps \
            labtyp=arcsec lines=2,3 nxy=1,1 slev=a,1 levs1=0.5 cols1=0
        if ($see == 'y') then
            gv $src.cmap.ps &
        endif
    endif
    rm -rf $src.*.gain $src.*.sen $src.*.snr
end

# Create a final gains set for export.
rm -rf $root.gains
gpcopy vis=$gaincalis[1]$ext out=$root.gains options=nopass mode=create
if ($nopasscals == 0) then
    gpcopy vis=passcals.mir out=$root.gains options=nocal mode=copy
endif
rm -f README
cat<<EOF > README

The file $root.gains contains the bandpass and time-dependent gains 
computed by quality. Apply them with the following MIRIAD commands 
(n.b. make a backup of the raw data first):
 
1. gpcopy vis=$root.gains out=$proj options=nocal 
2. uvcat vis=$proj out=$root.cal 
3. gpcopy vis=$root.gains out=$root.cal options=nopass 
 
This copies and applies the bandpass gains, then copies the time-
dependent gains.  This sequence is necessary so that systemp weighting 
takes the amplitude gains into account, via the senmodel parameter.
 
Caveats: Only the astronomical bandpass is contained in this file
(not the noise source).  There has been no flagging of data/gains
(besides shadowing) and no baseline correction has been applied.
Gains have NOT been bootstrapped using the flux calibrator.
EOF

#----------------------------- GRADE BLOCK -------------------------------
grading:

skip;echo "*** Grading the project"

echo " " | tee -a $logfile
# Calculate mean and median values for weather variables
@ N = 1
set value=(0 0 0)
foreach var (rmspath precipmm tau230)
    rm -f meanmed.out
    echo "Track statistics for ${var}:" | tee -a $logfile
    grep -v '#' $var.log | grep -v ' 0.000' | awk '{print $3}' > tmp.varplt
    meanmed infile=tmp.varplt | tee -a meanmed.out $logfile
    set median = `tail -1 meanmed.out | awk '{print $2}'`
    set mean = `tail -1 meanmed.out | awk '{print $3}'`
    set value[$N] = $median
    @ N++
    echo " " | tee -a $logfile
end

echo "The maximum baseline length for this track is $baselen m" | tee -a $logfile
#echo "The median baseline length for this track is $baselen m" | tee -a $logfile

if ( "$pacs" == "y" ) then
    # empirical effective baseline length for PACS is max baseline/4
    MATH x = $baselen / 4
    # convert to math
    set z = `echo "$x" | awk '{printf("%d\n",$1)}'`
    # Warning message
    echo "PACS mode: USING EFFECTIVE BASELINE OF $baselen / 4 = $z m" | tee -a $logfile
    # set baseline length to new effective value
    set baselen = $z
endif          

# Rmspath score, referenced to either 112 or 230 GHz
set intfreq=`calc -i "$lofreq"`
if (($intfreq < 150)&&($intfreq > 60)) then
    set reffreq = $ref3mm
endif 
if ($intfreq > 150) then
    set reffreq = $ref1mm
endif
if ($intfreq <60) then
    set reffreq = $ref1cm
endif
if ($reffreq == '0') then
    set reffreq=$lofreq
    set lambda2=$lambda
else
    set lambda2=`calc -f f8.6 "0.3/$reffreq"`
endif
set rmstau = `calc "$value[1]*2*PI/($lambda2*1e6)"`
set rmstau = `calc -f f6.2 "0.5*($rmstau**2)*($baselen/100)**0.833"`
echo "Effective opacity at $reffreq GHz due to phase noise: $rmstau" \
    | tee -a $logfile
echo "" | tee -a $logfile

# Precipmm score based on tipper data, referenced to either 112 or 230 GHz
if ("$tau230" == '') then
    echo "Atmospheric opacity based on tau225 from the tipper" | tee -a $logfile
else
    echo "User-specified value of tau230 is: $tau230" | tee -a $logfile
    set value[3] = $tau230
endif
if ($intfreq < 150) then
    # convert to mmh2o for obstau input
    set pwv=`calc -f f6.2 "($value[3]-0.005)/0.06"`
    # calculate tau(freq,zenith) for 3mm band
    set tauz=`obstau altitude=2.2 freq=$reffreq mmh2o=$pwv | tail -1 | awk '{print $8}'`
    set pwvtau=$tauz # no elev correction
else
    set pwvtau=$value[3] # no elev correction
endif
echo "Opacity at $reffreq GHz due to atmospheric absorption: $pwvtau" | tee -a $logfile

# Add the two to get total opacity
echo " " | tee -a $logfile
set tottau = `calc -f f6.2 "$rmstau+$pwvtau"`
echo "Total opacity: $tottau" | tee -a $logfile

# Find out what array configuration we are using
# e.g. proj=c0924.4D_88Serpen.SL.8 or proj=c0924V.3D_88Serpen.5
set arrStr = `echo $proj | cut -d . -f2 | cut -d _ -f1 | sed 's/[1-9]//g' `
echo "Using $arrStr array"

# If rmspath criteria are okay, then slope should change with configuration.
# E = 16, D = 21, C = 19, B = 19, Bw/PACS=14, Aw/PACS=13
if ($arrStr == "SL") then
    set tauGrad = 16
else if ($arrStr == "A") then
    set tauGrad = 13
else if ($arrStr == "B") then
    set tauGrad = 19
else if ($arrStr == "C") then
    set tauGrad = 19 
else if ($arrStr == "D") then
    set tauGrad = 21
else 
    set tauGrad = 16
endif

# Calculate the numerical grade
set finscore = `calc -i "100-$tauGrad*$tottau"`
echo "$arrStr ARRAY SCORE = 100-($tauGrad*tau) = $finscore" | tee -a $logfile

# Calculate the letter grades
if ( "$pacs" == "y" && $reffreq > 200) then
    echo "USING SPECIAL PACS 1mm GRADING CRITERIA" | tee -a $logfile
    grep -v '#' rmspath.log | grep -v ' 0.000' | awk '{print $3}' > tmp.varplt
    meanmed infile=tmp.varplt | tee -a meanmed.out
    set rmsmedian = `tail -1 meanmed.out | awk '{print $2}'`
    set mean = `tail -1 meanmed.out | awk '{print $3}'`
    echo "Adjusting grade for PACS:"
    set rmsmedian = `expr $rmsmedian+0`
    MATH x = $rmsmedian % 10
    set z = `echo "$x" | awk '{printf("%d\n",$1)}'`

    # special grades reserved
    if($z < 170) then
        set grade='A'
    else if($z > 220) then
        set grade='C'
    else
        set grade='B'
        echo "Marginal weather grade; requires user intervention for grading" | tee -a $logfile
    endif
    
    echo "median rms phase: $z micron"
    echo "PACS phasemonitor grade is $grade" | tee -a $logfile

endif
#else
if ($finscore >= 90) then
    set grade='A'
else if ($finscore >= 80) then
    set grade='B'
else if ($finscore >= 70) then
    set grade='C'
else if ($finscore >= 60) then
    set grade='D'
else 
    set grade='F'
endif
#endif

if ($grade != 'D' && $grade != 'F' && $finscore < 100) then
    @ remainder = $finscore % 10
    if ($remainder >= 7) then
        set sign='+'
    else if ($remainder < 3) then
        set sign='-'
    else
        set sign=' '
    endif
else if ($finscore >= 100) then
    set sign='+'
else
    set sign=' '
endif
set grade="$grade$sign"

echo "" | tee -a $logfile
echo "DEFAULT (WEATHER) GRADE: $grade" | tee -a $logfile

rm -f bsln.out meanmed.out

#--------------------------- CLEANUP BLOCK -------------------------------
cleanup:   # normal ending task, prepare archive files and clean up scratch
if ($pdb == 'y') then
    echo "qualityGrade project=$prjtag.$obstag opacity=$pwvtau phase=$value[1] grade=$finscore obslen=$totaltime imr=acc"
    qualityGrade project=$prjtag.$obstag opacity=$pwvtau phase=$value[1] \
        grade=$finscore obslen=$totaltime imr=acc
endif

# Convert the log to ps
if ($datatype == 4 || $datatype == 5) then
    enscript -r -f Courier7 $root.qq.log -o listobs.ps
else if ($datatype == 1 || $datatype == 6) then
    enscript -r -f Courier8 $root.qq.log -o listobs.ps
else
    enscript -r $root.qq.log -o listobs.ps
endif

# List of plots to archive, in order
set list=()
foreach file (rmspath tau230 bfmask tsys1 tsys2 tsys3 tsys4 linecal uvphase gns_amp gns_ph bpamp bpph bpph2 fluxcal)
    if (-e $file.ps) set list=($list $file.ps)
end
foreach src ($sourcelis)
    if (-e $src.map.ps) set list=($list $src.map.ps)
    if (-e $src.cmap.ps) set list=($list $src.cmap.ps)
end
gs -q -dSAFER -dNOPAUSE -dBATCH -sOutputFile=$root.listobs.pdf -sDEVICE=pdfwrite -c .setpdfwrite -f listobs.ps
gs -q -dSAFER -dNOPAUSE -dBATCH -sOutputFile=$root.plots.pdf -sDEVICE=pdfwrite -c .setpdfwrite -f $list
pdftk A=$root.listobs.pdf B=$root.plots.pdf cat A1-end B1-end output $root.qq.pdf

# Print the output if desired
if ( "$prn" == "y" ) then
    lp $root.qq.pdf
endif

# Archive the output
if ($REPORTS != "") then
    umask 002
    set archpth = $REPORTS/$prjtag/$obstag
    # organize reports by ISO date standard: YYYY-MM-DD
    set ISOdate = `julian date=$CalDate format=t options=d,q | cut -c1-10`
    set newarchpth = $REPORTS/$ISOdate/$prjtag/$obstag
    set pdfarchpth = $REPORTS/$ISOdate

    if (! -e $archpth) mkdir -p $archpth
    if (! -e $newarchpth) mkdir -p $newarchpth
    echo "Archiving quality report ..." 

    # make individual file for transfer to Illinois
    mkdir $root.quality
    cp $logfile $root.quality
    if (-e README) cp README $root.quality
    if (-e $root.gains) cp -r $root.gains $root.quality
    cp $root.qq.pdf $root.quality
    tar cf $root.quality.tar $root.quality
    gzip -f $root.quality.tar
    rm -rf $root.quality
    if ($pdb == 'y') cp -p $root.quality.tar.gz /opt/sdp/quality/transfer

    # copy files to local directories
    cp $logfile $archpth
    cp $logfile $newarchpth
    if (-e README && -e $root.gains) then
        tar cvzf $root.gains.tgz $root.gains README
        cp $root.gains.tgz $archpth
        cp $root.gains.tgz $newarchpth
    endif
    cp $root.qq.pdf $archpth
    cp $root.qq.pdf $newarchpth
    cp $root.qq.pdf $pdfarchpth
    skip;echo "Scratch files in $SCRATCH/$prjtag/$obstag"
    echo " will be DELETED in 5 sec - Ctrl-C to interrupt!"
    onintr finish
    sleep 5
    rm -rf $SCRATCH/$prjtag/$obstag
    if (`ls -A $SCRATCH/$prjtag` == '') rm -rf $SCRATCH/$prjtag
else
    echo ""
    echo "Scratch files in $SCRATCH/$prjtag/$obstag"
    echo " -- please delete these when done"
    rm -f tmp.*
endif
set endTimeInSec = `date +%s`
@ diffTimeInSec = $endTimeInSec - $startTimeInSec
set logmsg="{$YEAR} {$level} {$name} {$ndc} $scriptname Finished. Total run time= $diffTimeInSec sec. `date` by $USER on `hostname`"
logger -p "LOCAL2.INFO" "$logmsg"

exit 0

finish:  # end without deleting files
  onintr
  set endTimeInSec = `date +%s`
  @ diffTimeInSec = $endTimeInSec - $startTimeInSec
  set logmsg="{$YEAR} {$level} {$name} {$ndc} $scriptname finished. Total run time= $diffTimeInSec sec. `date` by $USER on `hostname`"
  logger -p "LOCAL2.INFO" "$logmsg"

  # Finish up
  if ($REPORTS != "") then
    echo "Archived report in $archpth"
    echo "Archived report in $newarchpth"
    echo "Archived report in $pdfarchpth"
  endif
  echo ""
  echo "If bandpass plots are empty, try repeating with bpsolint=60"
  echo "(or other large number) on the command line."
  echo ""
  echo "To repeat the script, just type:"
  echo "$0 proj=$proj sources=$sources gaincals=$gaincals passcals=$passcals fluxcal=$fluxcal"
  echo ""
  exit 0

abortcln:  # hitting Ctrl-C during the script usually goes here
  onintr 
  echo "Cleaning up..."
  set endTimeInSec = `date +%s`
  @ diffTimeInSec = $endTimeInSec - $startTimeInSec
  set logmsg="{$YEAR} {$level} {$name} {$ndc} $scriptname <ctrl-c> detected, Cleaning up. Total run time= $diffTimeInSec sec. `date` by $USER on `hostname`"
  logger -p "LOCAL2.INFO" "$logmsg"

  rm -rf $SCRATCH/$prjtag/$obstag
  if (`ls -A $SCRATCH/$prjtag` == '') rm -rf $SCRATCH/$prjtag
  echo "Cleanup completed."
  exit 1
