#!/bin/csh -f
#
# New CARMA quality script by Tony Wong (wongt@astro.uiuc.edu).
#
# NOTE: If you edit this script, make sure you get the latest version from
# CARMA/scripts:  $Id: quality-test,v 1.1 2010/10/12 21:20:37 tom Exp $
#
# Unlike the BIMA script, this expects a single MIRIAD file which contains
# all project data.  It takes advantage of new SMA plotting routines and
# can handle multiple frequency settings for the passband calibrator.
# It also estimates decorrelation by comparing scalar and vector averages
# after doing a phase-only selfcal, whereas the previous script did an
# amplitude & phase selfcal.  A new grading scheme is implemented, based
# on the total effective opacity at the observed frequency.
#
# When running offsite, the script expects the miriad data file to be in
# the current directory, and puts the results in the subdirectory quality/.
# These can be overridden with keywords DATADIR and SCRATCH.  The CARMA
# program meanmed should also be in the PATH; if not give its full path as a
# keyword: meanmed=/home/bin/...
#
# Version history:
#    07mar19   tw   grep out 0's from precipmm, rmspath; list sources found
#    07mar26   tw   mselfcal/smavarplt options; selfcal gaincals separately
#    07apr09   dnf  added reading of sdp.conf for directory data
#    07apr27   tw   reduce usage of smavarplt
#    07may11   tw   allow off-site use; switch from gawk to awk; tmax=0;
#                   average gains by ~5 min before UVAMP plot on fluxcal
#    07may26   mh   added the zenith opacity values (from the tipper data)
#                   and its plot
#    07jun13   tw   tidy up tipper code for offsite use; add linecal plot
#    07jun18   tw   calculate opacity at LO1, not "Rest Freq"
#    07jul03   tw   apply linelength; use tipper value if available
#    07aug17   tw   check tipper output, print rmspath instead of tipper plot;
#                   make 2 versions of Tsys plot, use max baseline for grade
#    07aug19   dnf  added pdb interface to quality
#    07oct02   tw   avoid double counting time if source and cal lists overlap
#    07dec04   tw   Calculate gain solution interval based on quasar flux.  
#                   Change several occurrences of wide,$buse,1 to wide,1,$buse.
#                   Use a priori (tabulated) fluxes for amplitude gains.
#    07dec10   tw   Eliminate cut commands for compatibility with new listobs.
#                   Delete scratch directory by default.
#    07dec12   tw   Further changes to accommodate further changes to listobs.
#                   Better support for off-site use. (plus minor doc//pjt)
#    08feb05   tw   Use purpose variable to set default source classification
#                   REQUIRES 04-feb-2008 version of listobs
#    08sep27   tw   Use csflag to flag shadowed data.
#    08dec16   tw   Generate PDF; generate gains file; image the sources
#    08dec21   tw   Some minor fixes to improve text output and plots
#    08dec22   tw   MWC349 is a fluxcal by default
#    09jan27   tw   Fix total time calculation to include NOISE; a couple typos
#                   in gains block when determining hybrid mode
#    09feb04   tw   Fix typo, $log -> $logfile
#    09mar09   tw   Do opacity calculations at 112 GHz (for 3mm) or 230 GHz,
#                   at NV's request.
#    09apr17   tw   Include tau230 plot in output.
#    09apr27   tw   Don't need external tipper plot anymore.
#    09may06   tw   Default bpsolint=1; default SCRATCH=/opt/szadata/obs/quality.
#                   Also change 'tail +5' to 'tail -n +5'
#    09jun17   nv   For 1mm data, use tau from tipper, without converting to
#                   pwv and back. Change slope of finscore calculation to 20.
#    09jun30   nv   Revise grade calc for zenith opacity. Slope of finscore
#                   calculation should be config dependent. E=16, D=21, C=19,
#                   B=19, Bw/PACS=14, Aw/PACS=13
#    09dec11   nv   Change qualityGrade to specify imr=acc
#    10jan19   nv   bsln lengths at 1mm wavelengths need 7 digits; change
#                   bsln.out calculation from "print" to "printf %d\n".
#    10may07   tw   Source image plots have nxy=4,2
#    10may19   tw   Tidy up appearance of cgdisp plot; ensure correct IF order
#    10jul12   tw   Default 1-minute averaging at start of processing
#    10jul13   tw   Don't uvaver by default
#    10jul29   rx   custom processing block for handling different types of data
#    10aug01   rx   change default settings according to data types
#_____________________________________________________________________________

set version=10aug01beta

# Required parameters (otherwise prompted)
set proj=
set sources=
set gaincals=
set passcals=
set fluxcal=

# Optional user parameters to enter on command line
set see=n                # Display the plots onscreen?
set prn=y                # Print the plots immediately?
set prn=n                # Print the plots immediately?
# Which spectral window to use for gain calibration.  Defaults to 1st widest.
set banduse=
# Value of 1mm opacity at zenith to override value in data file
set tau230=

# Default parameters (user can override on command line)
set refant=9             # Default ref antenna (usually a BIMA)
set pdb=y                # Default is to update pdb
set ovrorefant=3         # Default ref antenna for OVRO solution
set solint=5             # Selfcal interval (mins) to estimate decorrelation
                         # default for 3mm data
                                 
set bpsolint=1           # Selfcal interval (mins) for bandpass solution
set ampgainsolint=5      # Selfcal interval (mins) to estimate antenna gains
                         # (0 to calculate based on gaincal fluxes)
set tmax=1000            # Max for 2nd set of Tsys plots
set mselfcal=1           # Use Mike Regan's version of selfcal (1=true)
set smavarplt=1          # Use SMA version of varplt for tsys.ps (1=true)
set dolinecal=1          # Apply the linelength phases to data (1=true)
set edgeflag=2           # Number of edge channels to flag when imaging
set ref3mm=112           # Fiducial frequency for 3mm grading. 0 => use LO1
set ref1mm=230           # Fiducial frequency for 1mm grading. 0 => use LO1
set ref1cm=30            # # Fiducial frequency for 1mm grading. 0 => use LO1
set uvaver=0             # Averaging interval in minutes. 0 => no averaging
set offsite=0            # Set offsite=1 will override the on-site detection
                         # and set it offline

# If at CARMA, set up directory structure
#set scriptloc = `/usr/bin/dirname "$0"`
#set CONF = "${scriptloc}/../conf/sdp"
echo "WARNING - HARDWIRED CONF DIRECTORY"
set CONF = "/opt/rt/conf/sdp/"

if  ( (-e $CONF/sdp.conf) && ($offsite == 0) )  then
    echo "ON SITE"
    set TOP=`awk '{if ($1 =="top") print $3}' $CONF/sdp.conf`
    set SDP=`awk '{if ($1 =="sdp") {split($3,a,"/") ; print a[2]}}' $CONF/sdp.conf`
    set SCID=`awk '{if ($1 =="scienceDataFormatDir") {split($3,a,"/") ; print a[2]}}' $CONF/sdp.conf`
    set QDIR=`awk '{if ($1 =="qualityDir") {split($3,a,"/") ; print a[2]}}' $CONF/sdp.conf`
#    set TIPDIR=`awk '{if ($1 =="tipperDir") print $3}' $CONF/sdp.conf` 
    set DATADIR="$TOP/$SDP/$SCID"  # usually /opt/sdp/sciencedata
    set REPORTS="$TOP/$SDP/$QDIR"  # usually /opt/sdp/quality
#    set SCRATCH="/tmp/$QDIR"       # usually /tmp/quality
#    set SCRATCH="/opt/scratch/$QDIR"       # usually /opt/scratch/quality
    set SCRATCH="/opt/szadata/obs/$QDIR"       # usually /opt/szadata/obs/quality
    alias gv ghostview
else  # running off-site, presumably
    echo "OFF SITE (oh really?)"
    set DATADIR=`pwd`
    set SCRATCH=`pwd`/quality
    set pdb=n
endif

alias skip 'echo ""; echo "&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&"'

# Override above parameters if given on the command line
foreach a ( $* )
   set check=`echo $a | awk -F= '{print NF}'`
   if ( "$check" == 2 ) set $a
end

# Make sure the directories are defined
if ($?SCRATCH == 0 || $?DATADIR == 0) then
    echo "*** FATAL: DATADIR= and SCRATCH= keywords must be specified."
    exit 0
endif
if !(-e $DATADIR) then
    echo "*** FATAL: DATADIR directory $DATADIR not found"
    exit 0
endif

# Allow substitute routines
if ($?meanmed) then
    alias meanmed $meanmed
endif
if ($mselfcal == 1) alias selfcal mselfcal
if ($smavarplt == 1) then
    alias svarplt 'smavarplt dotsize=3'
else
    alias svarplt varplt
endif

# Generate filenames and directory structure
if ($proj == '') then
    if ($#argv == 1) then
        set proj=$1
    else
        echo "*** FATAL: proj= keyword must be specified."
        exit 0
    endif
endif
if ($proj:e == 'mir' || $proj:e == 'miriad') then
    set root = $proj:r
else
    set root = $proj
endif
set mirfile=$root.qual
set logfile=$root.qq.log

# project name will be in format: prjtag.obsBlock.mir
set pthtmp = `echo $proj | sed 's/\.mir[a-zA-Z]*//' | sed 's/\./\|/'`
set prjtag = `echo $pthtmp | awk '{split($1,a,"|"); print a[1]}'`
set obstag = `echo $pthtmp | awk '{split($1,a,"|"); print a[2]}'`
if !(-e $SCRATCH/$prjtag/$obstag) mkdir -p $SCRATCH/$prjtag/$obstag
cd $SCRATCH/$prjtag/$obstag
echo "Working in directory $SCRATCH/$prjtag/$obstag"
echo ""

if !(-e $DATADIR/$proj) then
    if !(-e $DATADIR/$proj.tar.gz) then 
        echo "*** FATAL: project file not found ***" 
        exit 0 
    else 
        echo "miriad file $DATADIR/$proj.tar.gz found. Extracting the data..." 
        tar -xzvf $DATADIR/$proj.tar.gz
        set DATADIR="$SCRATCH/$prjtag/$obstag" 
    endif
endif 

goto start
start:

# find out what array configuration we are using
set arrStr = `echo $1 | cut -d . -f2 | cut -d _ -f1 | sed 's/[1-9]//' `
echo "Using $arrStr array"
#

#------------------------ CUSTOM PROCESSING BLOCK ------------------------
# Default Custom Setting for data from DSS mode
# this part will be modfied as the dual array pipeline changes
#
echo "+++++++++++++++++++++++++++++++++++++"
echo "CARMA antennas in $DATADIR/$proj"
set ants = `listobs vis=$DATADIR/$proj | grep hhmmss | sed s/hhmmss//g | sed s/min// | sed s/deg//`
echo $ants

# determine the data type (sza or bima+ovro)
set obfound = 0
set szafound = 0
set datatype = 0
# datatype = 1  # ultimate mode (BIMA+OVRO+SZA, not implemented yet)
# datatype = 2  # sza LSB mode
# datatype = 3  # ovro+bima mode
# datatype = 4  # sza USB mode

foreach ant ($ants)
    if ($ant =~ {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}) then
        set obfound = 1
    endif
    if ($ant =~ {16,17,18,19,20,21,22,23}) then
        set szafound = 1
    endif
end

# TLC - Rui's original script tested $#lofreq <60 but $#lofreq = 1 
# always, so 90ghz data was not catered for. I added a numeric lo
# frequency variable nlofreq for the inequality
#set nlofreq = $lofreq | bc
set lofreq=`listobs vis=$DATADIR/$proj | awk '/First LO/ {print $10}'`
set nlofreq = `echo "$lofreq" | awk '{printf("%d\n",$1)}'`

echo "--- Data Type ---"
if (($szafound == 1)&&($obfound == 1)) then
    set datatype = 1
    echo "Ultimate mode: OVRO+BIMA+SZA"
endif
if (($szafound == 1)&&($obfound == 0)&&($nlofreq < 60 )) then
    set datatype = 2
    echo "SZA 1cm LSB Mode"
endif
if (($szafound == 1)&&($obfound == 0)&&($nlofreq > 60 )) then
    set datatype = 4
    echo "SZA 3mm USB Mode"
endif
if (($szafound == 0)&&($obfound == 1)) then
    set datatype = 3
    echo "OVRO+BIMA mode"
endif

echo "-------------------------------------"


#------------------------ LISTOBS BLOCK ----------------------------------
# Provides an observations summary and classifies the observed targets.

skip;echo "*** Copying and listing the data"

# Copy the cross-correlation data
if ($uvaver == '0') then
    rm -rf $mirfile
    uvcat vis=$DATADIR/$proj out=$mirfile select='-auto'
else
    rm -rf $mirfile uvaver.mir
    uvaver vis=$DATADIR/$proj out=uvaver.mir select='-auto' interval=$uvaver
    uvlist vis=uvaver.mir options=var,full log=tmp.uvlist
    set nspect=`grep nspect tmp.uvlist | sed 's/.*nspect[ ]*://' | awk '{print $1}'`
    echo "Re-creating $nspect wideband windows"
    uvwide vis=uvaver.mir out=$mirfile nwide=$nspect
endif

# Output some useful diagnostics, including UT, LST, and weather data
# this is the new 11-dec-2007 listobs with both UT,LST cols, no more BW/mode from bima times
listobs vis=$mirfile log=listobs1
foreach var (rmspath tau230 precipmm)  # currently tau230 mirrors precipmm
   varplt vis=$mirfile yaxis=$var log=$var.log device=$var.ps/ps
end

# Get the number of NOISE integrations
set beglin=`awk '/Sys Temps/ {print NR}' listobs1`
@ beglin ++
@ beglin ++
set endlin=`wc listobs1 | awk '{print $1-1}'`
sed -n "$beglin,${endlin}p" listobs1 > listobs.tab
set nnoise=`grep NOISE listobs.tab | wc | awk '{print $1}'`

# Get the date and frequency
set CalDate=`awk '/Chronology/ {print $5}' listobs1`
set lofreq=`awk '/First LO/ {print $10}' listobs1`
set restfreq=`awk '/Rest Freq/ {print $6}' listobs1`

echo "+++++++++++++++++++++"
echo "LO: $lofreq GHz"
echo "ResFreq: $restfreq GHz"
echo "---------------------"

# Begin writing the logfile
echo "PROJECT=$proj  DATE=$CalDate  Q_RUN_TIME($HOST,v.$version)=`date`" | tee $logfile
echo -n '---------------------------------------------' | tee -a $logfile
echo    '---------------------------------------------' | tee -a $logfile

# Reload the data, this time eliminating the NOISE scans.
if ($uvaver == '0') then
    rm -rf $mirfile
    uvcat vis=$DATADIR/$proj out=$mirfile select='-auto,-source(NOISE)'
else
    rm -rf $mirfile.ave
    mv $mirfile $mirfile.ave
    uvcat vis=$mirfile.ave out=$mirfile select='-source(NOISE)'
    rm -rf $mirfile.ave
endif

# remove LSB/USB data for SZA AGAIN - c shell doesn't support functions.
#+ Need to remove a sideband for SZA data
# SZA Mode: 
# 1cm data are in LSB
if ($datatype == 2) then
    rm -rf $mirfile.tmp
    uvcat vis=$mirfile out=$mirfile.tmp \
        select='win(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)' options=nowide
    uvlist vis=$mirfile.tmp options=var,full log=tmp.uvlist0
    set nspect=`grep nspect tmp.uvlist0 | sed 's/.*nspect[ ]*://' | awk '{print $1}'`
    echo "Re-creating $nspect wideband windows" 
    rm -rf $mirfile
    uvwide vis=$mirfile.tmp out=$mirfile nwide=$nspect
    rm -rf $mirfile.tmp
    set refant=21
endif

# 3mm data are in USB
if ($datatype == 4) then
    uvcat vis=$mirfile out=$mirfile.tmp \
        select='win(17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32)' options=nowide
    uvlist vis=$mirfile.tmp options=var,full log=tmp.uvlist0
    set nspect=`grep nspect tmp.uvlist0 | sed 's/.*nspect[ ]*://' | awk '{print $1}'`
    echo "Re-creating $nspect wideband windows" 
    rm -rf $mirfile
    uvwide vis=$mirfile.tmp out=$mirfile nwide=$nspect
    rm -rf $mirfile.tmp
    set refant=21
endif

if ($nlofreq < 60) then
    set solint=5
    set tmax=150
    set ampgainsolint=5
endif
#-

listobs vis=$mirfile log=listobs2


# Include the listobs output
set beglin=`awk '/Sys Temps/ {print NR}' listobs2`
sed -n "${beglin}p" listobs2 | sed "s/(K)/& near $lofreq GHz (LO1)/" | tee -a $logfile
#sed -n "${beglin}p" listobs2 | sed "s/(K)/& near $restfreq GHz (rest freq)/" | tee -a $logfile
@ beglin ++
set endlin=`wc listobs2 | awk '{print $1-1}'`
sed -n "$beglin,${endlin}p" listobs2 | tee -a $logfile
set ants=`sed -n "${beglin}p" listobs2 | sed 's/\(.*[deg,mode]\)//'`

# Get the maximum and median baseline length
set lambda=`calc -f f8.6 "0.3/$lofreq"` # meters
# set lambda=`calc -f f8.6 "0.3/$restfreq"` 
grep Bsln listobs2 | sed 's/\(.*:\)//' | awk '{printf "%d\n", sqrt($1^2 + $2^2 + $3^2)}' \
    >! bsln.out
set maxbsln=`sort -n bsln.out | tail -1`
set medbsln=`meanmed infile=bsln.out | tail -1 | awk '{print $2}'`
set baselen=`calc -f f8.2 "$lambda*$maxbsln"`

# Get the source list and their intents
set beglin2=`awk '/Observed Sources/ {print NR+2}' listobs2`
set endlin2=`awk '/Frequency Set-up/ {print NR-2}' listobs2`
set allobs=`sed -n "$beglin2,${endlin2}p" listobs2 | awk '{print $1}'`
set purpose=`sed -n "$beglin2,${endlin2}p" listobs2 | awk '{print $2}'`
set i=1
set defsources=
set defgaincals=
set defpasscals=
set deffluxcal=
echo "" | tee -a $logfile
while ($i <= $#allobs)
    if ($purpose[$i] =~ *B*) set defpasscals = ($defpasscals $allobs[$i])
    if ($purpose[$i] =~ *G*) set defgaincals = ($defgaincals $allobs[$i])
    if ($purpose[$i] =~ *S*) set defsources = ($defsources $allobs[$i])
    if ($purpose[$i] =~ *F*) set deffluxcal = ($deffluxcal $allobs[$i])
    if ($purpose[$i] =~ *A*) set defsources = ($defsources $allobs[$i])
    if ($purpose[$i] =~ *O*) set defgaincals = ($defgaincals $allobs[$i])
    echo "Source $allobs[$i] has purpose $purpose[$i]" | tee -a $logfile
    set i = `expr $i + 1`
end
# If there are 2 or more passcals, remove planets:
if ($#defpasscals > 1) then
    foreach passcal ($defpasscals)
        if ($passcal =~ {MERCURY,VENUS,MARS,JUPITER,SATURN,URANUS,NEPTUNE,MWC349}) then
            if ($#defpasscals > 1) then
                set defpasscals=`echo $defpasscals | sed "s/$passcal//"`
            endif
        endif
    end
endif
# If there are 2 or more gaincals, remove planets:
if ($#defgaincals > 1) then
    foreach gaincal ($defgaincals)
        if ($gaincal =~ {MERCURY,VENUS,MARS,JUPITER,SATURN,URANUS,NEPTUNE,MWC349}) then
            if ($#defgaincals > 1) then
                set defgaincals=`echo $defgaincals | sed "s/$gaincal//"`
            endif
        endif
    end
endif
# If there are 2 or more fluxcals, choose a planet:
if ($#deffluxcal > 1) then
    foreach obj ($deffluxcal)
        if ($obj !~ {MERCURY,VENUS,MARS,JUPITER,SATURN,URANUS,NEPTUNE,MWC349}) then
            if ($#deffluxcal > 1) then
                set deffluxcal=`echo $deffluxcal | sed "s/$obj//"`
            endif
        endif
    end
    if ($#deffluxcal > 1) set deffluxcal=$deffluxcal[1]
endif
# State the default classifications
echo ""
echo "Default assignments, based on source intent:"
echo "sources : $defsources"
echo "gaincals: $defgaincals"
echo "passcals: $defpasscals"
echo "fluxcal: $deffluxcal"

# Prompt for override if we're running without command-line arguments
if ($sources == '' && $gaincals == '') then
    echo "Note: sources and gaincals are required"
    echo -n "Do you wish to override these choices [n]? "  
    set resp="$<"
    if ($resp == 'y') then
        echo ""
        echo -n "Enter names of program sources, comma-separated: "
        set sources=`echo "$<" | sed 's/ //g'`
        echo -n "Enter names of gaincals, comma-separated: "
        set gaincals=`echo "$<" | sed 's/ //g'`
        echo -n "Enter names of passcals, comma-separated (OK to repeat gaincal names): "
        set passcals=`echo "$<" | sed 's/ //g'`
        echo -n "Enter name of the fluxcal (blank if none): "
        set fluxcal="$<"
    else
        set sources=`echo $defsources | sed 's/ /,/g'`
        set gaincals=`echo $defgaincals | sed 's/ /,/g'`
        set passcals=`echo $defpasscals | sed 's/ /,/g'`
        set fluxcal=$deffluxcal
    endif
else  # use the command-line parameters, with intent as fallback
    if ($sources == '') set sources=`echo $defsources | sed 's/ /,/g'`
    if ($gaincals == '') set gaincals=`echo $defgaincals | sed 's/ /,/g'`
    if ($passcals == '') set passcals=`echo $defpasscals | sed 's/ /,/g'`
    if ($fluxcal == '') set fluxcal=$deffluxcal
endif

# Compile lists of sources
set sourcelis=`echo "$sources" | sed 's/,/ /g'`
set gaincalis=`echo "$gaincals" | sed 's/,/ /g'`
set passcalis=`echo "$passcals" | sed 's/,/ /g'`
set allcals = ()
set allobjs = ()
foreach obj ($gaincalis $passcalis $fluxcal)
    set val=`echo $allcals | grep $obj`
    if ("$val" == "") set allcals = ($obj $allcals)
end
foreach obj ($sourcelis $gaincalis $passcalis $fluxcal)
    set val=`echo $allobjs | grep $obj`
    if ("$val" == "") set allobjs = ($obj $allobjs)
end

# Announce object classification
echo "" | tee -a $logfile
echo "sources : $sources" | tee -a $logfile
echo "gaincals: $gaincals" | tee -a $logfile
echo "passcals: $passcals" | tee -a $logfile
echo "fluxcal: $fluxcal" | tee -a $logfile

# Get the elapsed project time, note this includes NOISE integrations
head -1 listobs.tab > log1
tail -1 listobs.tab > log2
set starttime=`awk '{print $2}' log1`
set stoptime=`awk '{print $2}' log2`
set starthours=`echo $starttime | awk '{split ($1,h,""); print h[1] h[2]}'`
set startminutes=`echo $starttime | awk '{split ($1,h,""); print h[3] h[4]}'`
set stophours=`echo $stoptime | awk '{split ($1,h,""); print h[1] h[2]}'`
set stopminutes=`echo $stoptime | awk '{split ($1,h,""); print h[3] h[4]}'`
set addminutes=`awk '{print $4}' log2`

set starttime = `calc -f f6.3 "$starthours+$startminutes/60.0"`
set stoptime  = `calc -f f6.3 "$stophours+($stopminutes+$addminutes)/60.0"`
set stoptime  = `echo $starttime $stoptime | awk '{if ($1 > $2) print ($2 + 24); else print $2}'`
set totaltime = `calc -f f6.1 "$stoptime-$starttime"`
# Total time is reported in the OBSTIME block
rm -f listobs1 log[1-2]

# CUSTOM PROCESSING OPTIONS WENT HERE
# Override above parameters if given on the command line AGAIN!
foreach a ( $* )
   set check=`echo $a | awk -F= '{print NF}'`
   if ( "$check" == 2 ) set $a
end
# Choose a new reference antenna if default is unavailable
set reffound = 0
foreach ant ($ants)
    if ($refant == $ant) then
        set reffound = 1
    endif
end
if ($reffound == 0) then
    echo "*** WARNING: Requested reference antenna $refant not found"
    set refant = $ants[1]
endif
echo "There were $nnoise NOISE integrations" | tee -a $logfile
if ($uvaver != '0') then
    echo "Visibility data averaged over $uvaver minute interval" | tee -a $logfile
endif
echo "Using $refant as the reference antenna" | tee -a $logfile


#------------------------ SYSTEMP BLOCK ----------------------------------

skip;echo "*** Plotting system temperatures"

if (($datatype == 2) || ($datatype == 4)) then
    svarplt vis=$mirfile yaxis=systemp nxy=6,4 device=tsys1.ps/cps
    svarplt vis=$mirfile yaxis=systemp nxy=6,4 device=tsys2.ps/cps \
        yrange=0,$tmax

    # remove 6+10m telescope page
    #psselect -p2 tsys1.ps tsys1.ps
    #psselect -p2 tsys2.ps tsys2.ps

else
    svarplt vis=$mirfile yaxis=systemp nxy=3,5 device=tsys1.ps/cps
    svarplt vis=$mirfile yaxis=systemp nxy=3,5 device=tsys2.ps/cps \
        yrange=0,$tmax
endif

if (-X psselect) then
    psselect -p1 tsys1.ps tmp1.ps
    mv tmp1.ps tsys1.ps
    psselect -p1 tsys2.ps tmp2.ps
    mv tmp2.ps tsys2.ps
endif
if ($see == 'y') then
    gv tsys1.ps &
endif

#--------------------------- CSFLAG BLOCK -------------------------------

skip;echo "*** Flagging shadowed data"

csflag vis=$mirfile carma=True > tmp.csflag
echo -n "csflag:" | tee -a $logfile
tail -1 tmp.csflag | tee -a $logfile

#--------------------------- LINECAL BLOCK -------------------------------

skip;echo "*** Plotting the linelength phases"

rm -rf linecal.gains
linecal vis=$mirfile out=linecal.gains
gpplt vis=linecal.gains yaxis=phase yrange=-180,180 options=wrap,dots \
    device=linecal.ps/ps nxy=3,5
if ( $dolinecal != 0 ) then
    gpcopy vis=linecal.gains out=$mirfile
endif
if ($see == 'y') then
    gv linecal.ps &
endif

#--------------------------- OBSTIME BLOCK--------------------------------

skip;echo "*** Evaluating observing time statistics"

echo "" | tee -a $logfile
echo "Total project time $totaltime hrs from start to finish" | tee -a $logfile

# Split the data in order to get time on each source
set timesum=0
foreach obj ($allobjs)
    rm -rf $obj
    uvcat vis=$mirfile out=$obj select="source($obj)" options=unflagged
    uvindex vis=$obj log=tmp.uvindex
    set term=`grep "Total observing time" tmp.uvindex | awk '{print $5}'`
    echo "Total observe time $term hrs for $obj" | tee -a $logfile
    set timesum=`echo "$timesum+$term" | bc -l`
end
echo "Total observe time $timesum hrs for entire track" | tee -a $logfile

#--------------------------- UVDISTANCE BLOCK------------------------------
# Plot calibrated phases vs. uv-distance.
# Calibrates the gaincal data and estimates decorrelation over 5 mins.

skip;echo "*** Plotting calibrated phase vs. uvdistance"

# Merge the gain calibrators into a single dataset
rm -rf gaincals.mir
uvcat vis=$mirfile select="source($gaincals)" options=nopol,nopass \
    out=gaincals.mir

# Determine the correlator setup on gain calibrators
prthd in=gaincals.mir options=full log=tmp.prthd 
set beglin=`awk '/Bandwidth/ {print NR}' tmp.prthd`
@ beglin ++
set endlin=`awk '/J2000/ {print NR}' tmp.prthd`
set endlin=`expr $endlin - 3`
sed -n "$beglin,${endlin}p" tmp.prthd > tmp.corr1
set corrno = `cat tmp.corr1 | awk '{print $1}'`
set corfreq = `cat tmp.corr1 | awk '{print $2}'`
set bandwcal = `cat tmp.corr1 | awk '{printf "%5d", 1000*sqrt($3*$3)}'`

# Determine the correlator setup on sources
prthd in=$sourcelis[1] options=full log=tmp.prthd 
set beglin=`awk '/Bandwidth/ {print NR}' tmp.prthd`
@ beglin ++
set endlin=`awk '/J2000/ {print NR}' tmp.prthd`
set endlin=`expr $endlin - 3`
sed -n "$beglin,${endlin}p" tmp.prthd > tmp.corr2
set srcfreq = `cat tmp.corr2 | awk '{print $2}'`
set bandwsrc = `cat tmp.corr2 | awk '{printf "%5d", 1000*sqrt($3*$3)}'`

# Output information about the correlator setup
echo "" | tee -a $logfile

#++++
if ($datatype == 2) then
    echo "-"
    echo "**SZA Data: only LSB data are processed**" | tee -a $logfile
    echo "-"
endif
if ($datatype == 4) then
    echo "-"
    echo "**SZA Data: only USB data are processed**" | tee -a $logfile
    echo "-"
endif
if ($datatype == 3) then
    echo "-"
    echo "**BIMA+OVRO Data**" | tee -a $logfile
    echo "-"
endif
if ($datatype == 1) then
    echo "-"
    echo "**BIMA+OVRO+SZA Data**" | tee -a $logfile
    echo "-"
endif
#----

echo "Correlator setup for gain calibrators:" | tee -a $logfile
cat tmp.corr1 | tee -a $logfile
echo "Correlator setup for sources:" | tee -a $logfile
cat tmp.corr2 | tee -a $logfile

# Get the first 500 MHz window on phasecal, otherwise just use largest bw
if ("$banduse" != "") then
    set buse=$banduse
    goto setbeuse
endif
set maxbw = 0
foreach i ($corrno)
    if (`echo $bandwcal[$i] | awk '{print ($1>400)}'` == 1) then
        set buse = $i
        goto setbeuse
    else if (`echo $bandwcal[$i] $maxbw | awk '{print ($1>$2)}'` == 1) then
        set buse = $i
        set maxbw = $bandwcal[$i]
    endif
end
setbeuse:
echo "Using window $buse, BW $bandwcal[$buse] MHz for gain calibration" \
    | tee -a $logfile

# Calibrate the phase only using a $solint minute solution interval.
selfcal vis=gaincals.mir line=wide,1,$buse interval=$solint refant=$refant \
    options=phase

# Plot the phase vs uv-distance.
uvplt vis=gaincals.mir axis=uvd,phase nxy=1,1 options=nobase,2pass \
    device=uvphase.ps/ps yrange=-180,180 line=wide,1,$buse inc=10 size=1,2
if ($see == 'y') then
    gv uvphase.ps &
endif

# Make an estimate of the time interval needed to obtain S/N ~ 8 on a 6m-6m
# baseline.  This will be used to determine the default gain solution interval.
set snr=8

# Get the jyperk and median systemp on the reference antenna
foreach var (systemp jyperka)
    varplt vis=gaincals.mir yaxis=$var log=$var.log1 options=compress
    sed -e :a -e '$\!N;s/\n  / /;ta' -e 'P;D' $var.log1 > $var.log2
    set colno=`expr $refant + 2`
    cat $var.log2 | grep -v '#' | awk '{print $s}' s=$colno | \
        grep -v '[:alpha:]' > $var.log3
    meanmed infile=$var.log3 | tee $var.log4
end
set mtsys = `tail -1 systemp.log4 | awk '{print $2}'`
set jyperk = `tail -1 jyperka.log4 | awk '{print $2}'`

# Use the mean gaincal flux as the nominal flux value
calred vis=gaincals.mir line=wide,1,$buse > calred.log
set beglin=`awk '/Source/ {print NR+1}' calred.log`
set flux=`sed -n "$beglin,999p" calred.log | awk '{s += $3} END {printf "%5.2f\n", 1e-3*s/NR}'`

# Get the default gain solution interval, quantized by 30s, bounded by 0.5 & 5 min
set t30=`calc -i "($jyperk*$mtsys*$snr)**2/(30*2*$bandwcal[$buse]*1e6*$flux**2)"`
if (`echo $t30 | awk '{print ($1<1)}'` == 1) then
    set defgainsolint=0.5
else if (`echo $t30 | awk '{print ($1>10)}'` == 1) then
    set defgainsolint=5
else
    set defgainsolint=`calc -f f4.1 "$t30*0.5"`
endif
if ($ampgainsolint == 0) then
    echo "Median T_sys for Ant $refant is $mtsys"  | tee -a $logfile
    echo "Nominal Jy/K for Ant $refant is $jyperk" | tee -a $logfile
    echo "Mean flux for gaincals is $flux pseudo-Jy" | tee -a $logfile
    echo "Using flux-based gain solution interval of $defgainsolint min" \
        | tee -a $logfile
    set ampgainsolint=$defgainsolint
else
    echo "Using gain solution interval of $ampgainsolint min" \
        | tee -a $logfile
endif

# Estimate decorrelation ratio using a 5 (3mm) or 20 (1cm) minute solution interval.
echo "" | tee -a $logfile
echo "*******************************************************************" | \
tee -a $logfile
echo "decorrelation estimated from the ratio of vector to scalar averaged" | \
tee -a $logfile
echo "amplitudes following a phase-only selfcal with a $solint min interval." | \
tee -a $logfile
echo "" | tee -a $logfile
uvflux vis=gaincals.mir line=wide,1,$buse >! tmp.uvflux
echo "  source       vec_avg    phase_coherence" | tee -a $logfile
echo "----------     -------    ---------------" | tee -a $logfile
egrep '(E-|E+)' tmp.uvflux | \
awk '{printf "%10s %10.2f %15.2f\n", $1, $4, $4/$7}' | tee -a $logfile

rm -rf gaincals.mir systemp.log[1-4] jyperka.log[1-4]

#------------------------------ PASSBAND BLOCK ------------------------------
# Calibrates the bandpass and copies bandpass gains to data.

skip;echo "*** Calibrating the bandpass"

# Skip this if no passband calibrators.
if ( "$passcals" == "" ) then
    set nopasscals=1
    goto flux
else
    set nopasscals=0
endif

# Select the appropriate passband data.
rm -rf passcals.mir
uvcat vis=$mirfile select="source($passcals)" options=nopol,nopass \
    out=passcals.mir
#bwsel vis=passcals.mir out=passcals.nar bw="$bandwsrc"

# Compute the passband solutions and plot.
mfcal vis=passcals.mir interval=$bpsolint refant=$refant
smagpplt vis=passcals.mir options=bandpass,nofit device=bpamp.ps/cps \
    xaxis=chan yrange=0,2 nxy=3,3 filelabel=1
if ($see == 'y') then
    gv bpamp.ps &
endif
smagpplt vis=passcals.mir options=bandpass,wrap,nofit device=bpph.ps/cps \
    xaxis=chan yaxis=phase yrange=-180,180 nxy=3,3 filelabel=1
if ($see == 'y') then
    gv bpph.ps &
endif

# Estimate decorrelation ratio.  This requires selecting the wideband data
# in the case of hybrid mode.
rm -rf passcals.wid
bwsel vis=passcals.mir out=passcals.wid bw="$bandwcal"
selfcal vis=passcals.wid line=wide,1,$buse interval=$solint refant=$refant \
    options=phase
uvflux vis=passcals.wid line=wide,1,$buse >! tmp.uvflux
egrep '(E-|E+)' tmp.uvflux | \
    awk '{printf "%10s %10.2f %15.2f\n",$1,$4,$4/$7}' > tmp.uvflux2
foreach gcal ($gaincalis)
    grep -v $gcal tmp.uvflux2 > tmp.uvflux
    mv tmp.uvflux tmp.uvflux2
end
cat tmp.uvflux2 | tee -a $logfile

#----------------------------- FLUXCAL BLOCK -------------------------------
flux:

skip;echo "*** Examining flux calibrator"

# Estimate decorrelation ratio
if ($fluxcal != '') then
    selfcal vis=$fluxcal options=phase \
        line=wide,1,$buse refant=$refant interval=$solint
    uvflux vis=$fluxcal line=wide,1,$buse >! tmp.uvflux
    egrep '(E-|E+)' tmp.uvflux | \
        awk '{printf "%10s %10.2f %15.2f\n",$1,$4,$4/$7}' > tmp.uvflux2
    foreach cal ($gaincalis $passcalis)
        grep -v $cal tmp.uvflux2 > tmp.uvflux
        mv tmp.uvflux tmp.uvflux2
    end
    cat tmp.uvflux2 | tee -a $logfile

# Output absolute amplitude gains
    echo "" | tee -a $logfile
    echo -n "Calibrated antenna gains from $fluxcal" | tee -a $logfile
    echo " (soln interval $ampgainsolint min)" | tee -a $logfile
    set dofile=$fluxcal
    if ($#passcalis == 1 && "$passcalis" != '') then
        if ("$fluxcal" == "$passcalis[1]") set dofile=passcals.wid
    endif
    selfcal vis=$dofile options=apriori,amplitude,noscale \
        line=wide,1,$buse refant=$refant interval=$solint
#    gpaver vis=$dofile interval=$solint options=scalar
    uvamp vis=$dofile line=wide,1,$buse device=fluxcal.ps/ps
#    smauvamp vis=$dofile line=wide,1,$buse device=fluxcal.ps/ps \
#        axis=uvd,amp nbin=20 options=zero
    if ($see == 'y') then
        gv fluxcal.ps &
    endif
    gpaver vis=$dofile interval=1000 options=scalar
    gpplt vis=$dofile yaxis=amp log=ampgains.dat
    tail -n +5 ampgains.dat | tee -a $logfile
endif

rm -rf passcals.wid

#----------------------------- GAINS BLOCK -------------------------------
gains:

skip;echo "*** Calibrating the gains"

# Apply the bandpass to gain calibrators
if ($nopasscals == 0) then
    foreach cal ($gaincalis)
        gpcopy vis=passcals.mir out=$cal options=nocal
        echo "Passband gains copied to $cal"
        uvlist vis=$cal options=var,full log=tmp.uvlist
        set delf=`grep sdf tmp.uvlist | tail -1 | sed 's/.*sdf[ ]*://' | awk '{print 1e3*sqrt($1**2)}'`
        set nchan=`grep nchan tmp.uvlist | sed 's/.*nchan[ ]*://' | awk '{print $1}'`
        set npass=`gethd in=$cal/nchan0`
        echo "nchan for data, bandpass: $nchan $npass"
        if ($nchan < $npass) then
            bpsel vis=$cal fmhz=$delf tol=0.1
            echo "Selected gains with freq resolution $delf MHz" | tee -a $logfile
            echo ""
            set hybrid=y
        endif
    end
endif

# Use a BIMA antenna as reference
# Plot gains(time) using a short solution interval
rm -rf refant$refant.gains
foreach cal ($gaincalis)
    selfcal vis=$cal line=wide,1,$buse interval=$ampgainsolint \
        refant=$refant options=amplitude,apriori,noscale
    if ($cal == $gaincalis[1]) then
        gpcopy vis=$cal out=refant$refant.gains mode=create
    else
        gpcopy vis=$cal out=refant$refant.gains mode=merge
    endif
end
gpplt vis=refant$refant.gains nxy=5,3 yaxis=amp yrange=0,4 \
    device=bimagns_amp.ps/ps
gpplt vis=refant$refant.gains nxy=5,3 yaxis=phase yrange=-180,180 \
    options=wrap device=bimagns_ph.ps/ps
if ($see == 'y') then
    gv bimagns_amp.ps &
    gv bimagns_ph.ps &
endif
gpcopy vis=refant$refant.gains out=refant$refant.avgains mode=create
puthd in=refant$refant.gains/senmodel value='GSV' type=ascii
puthd in=refant$refant.gains/interval value=0.1 type=real

# Plot the bandpass if there was no bandpass cal.
#if ($nopasscals == 1) then
#    mfcal vis=refant$refant.mir interval=$bpsolint refant=$refant
#    smagpplt vis=refant$refant.mir options=bandpass,nofit filelabel=1 \
#    device=bpamp.ps/cps xaxis=chan yrange=0,2 nxy=3,3
#    smagpplt vis=refant$refant.mir options=bandpass,wrap,nofit filelabel=1 \
#    device=bpph.ps/cps xaxis=chan yaxis=phase yrange=-180,180 nxy=3,3
#    if ($see == 'y') then
#        gv bpamp.ps &
#        gv bpph.ps &
#    endif
#endif

# Average the amplitude gains and report to logfile
gpaver vis=refant$refant.avgains interval=1000 options=scalar
gpplt vis=refant$refant.avgains yaxis=amp log=ampgains.dat
echo "" | tee -a $logfile
echo -n "Calibrated antenna gains from $gaincals" | tee -a $logfile
echo " (soln interval $ampgainsolint min)" | tee -a $logfile
tail -n +5 ampgains.dat | tee -a $logfile

# Use an OVRO antenna as reference; plot gains vs. time
set ovrofound = 0
foreach ant ($ants)
    if ($ovrorefant == $ant) then
        set ovrofound = 1
    endif
end
if ($ovrofound == 1) then
    rm -rf refant$ovrorefant.gains
    foreach cal ($gaincalis)
        selfcal vis=$cal line=wide,1,$buse interval=$ampgainsolint \
            refant=$ovrorefant options=amplitude,apriori,noscale
        if ($cal == $gaincalis[1]) then
            gpcopy vis=$cal out=refant$ovrorefant.gains mode=create
        else
            gpcopy vis=$cal out=refant$ovrorefant.gains mode=merge
        endif
    end
    gpplt vis=refant$ovrorefant.gains nxy=5,3 yaxis=phase yrange=-180,180 \
        options=wrap device=ovrogns_ph.ps/ps
#    rm -rf refant$ovrorefant.mir
#    mv refant$refant.mir refant$ovrorefant.mir
#    selfcal vis=refant$ovrorefant.mir line=wide,1,$buse \
#        interval=$ampgainsolint refant=$ovrorefant options=amplitude,apriori,noscale
    if ($see == 'y') then
        gv ovrogns_ph.ps &
     endif
endif

#rm -rf refant$refant.mir refant$ovrorefant.mir
rm -f ampgains.dat

#----------------------------- IMAGE BLOCK -------------------------------
image:

skip;echo "*** Imaging the sources"

# Copy gains to sources and make images of each:
foreach src ($sourcelis)
    # Copy the bandpass gains
    echo " " | tee -a $logfile
    uvlist vis=$src options=spectra log=tmp.uvlist1
    set ch0=`grep 'starting chan' tmp.uvlist1 | sed 's/.*:[ ]*//'`
    set nch=`grep number tmp.uvlist1 | sed 's/.*:[ ]*//'`
    uvlist vis=$src options=var,full log=tmp.uvlist
    if ($nopasscals == 0) then
        gpcopy vis=passcals.mir out=$src options=nocal
        echo "Passband gains copied to $src" | tee -a $logfile
        set delf=`grep sdf tmp.uvlist | tail -1 | sed 's/.*sdf[ ]*://' | awk '{print 1e3*sqrt($1**2)}'`
        set nchan=`grep nchan tmp.uvlist | sed 's/.*nchan[ ]*://' | awk '{print $1}'`
        set npass=`gethd in=$src/nchan0`
        echo "nchan for data, bandpass: $nchan $npass"
        if ($nchan < $npass) then
            bpsel vis=$src fmhz=$delf tol=0.1
            echo "Selected gains with resolution $delf MHz" | tee -a $logfile
            set hybrid=y
        endif
    endif
    # Apply bandpass gains, flag edge channels, copy gains
    rm -rf $src.cal
    uvcat vis=$src out=$src.cal
    uvflag vis=$src.cal edge=$edgeflag flagval=f
    gpcopy vis=refant$refant.gains out=$src.cal options=nopass
    set nspect=$#srcfreq
    # Loop through the spectral windows, generating maps.
    set i=1
    set im=1
    rm -f $src.olay
    while ($i <= $nspect)
        set id=`printf "%02d" $i`
        rm -rf $src.$id.map $src.$id.beam
        set pow=`calc -i "1+log(1e4/$baselen/$lofreq)/log(2)"`
#        set pow=`calc -i "1+log(1e4/$baselen/$restfreq)/log(2)"`
        set cell=`echo $pow | awk '{print 2**$1}'`
        if ($pow > 1) then
            set imsize=128
        else if ($pow < -1) then
            set imsize=512
        else
            set imsize=`echo $pow | awk '{print 2**(8-$1)}'`
        endif
        invert vis=$src.cal map=$src.$id.map beam=$src.$id.beam imsize=$imsize \
            cell=$cell line=chan,1,$ch0[$i],$nch[$i] options=systemp,mosaic \
            robust=1 | tee tmp.invert
        rm -rf $src.$id.sen $src.$id.gain
        mossen in=$src.$id.map sen=$src.$id.sen gain=$src.$id.gain
        rm -rf $src.$id.snr
        set minval=`histo in=$src.$id.sen | grep Min | awk '{printf "%3.1e",$3}'`
        echo "Normalizing $src.$id.sen by $minval"
        maths exp="<$src.$id.map>/<$src.$id.sen>" out=$src.$id.snr
        if (-e $src.$id.snr) then
            echo "Window $id has theoretical rms $minval Jy at map center" \
                | tee -a $logfile
            set xpos=0
            set ypos=`gethd in=$src.$id.map/naxis2 | awk '{printf "%d",$1*0.88*0.25}'`
            echo -n "clear relpix relpix " >> $src.olay
            echo -n "$srcfreq[$i]/${bandwsrc[$i]}MHz/\gs=$minval " >> $src.olay
            echo "yes $xpos $ypos $im $im" >> $src.olay
            set im=`expr $im + 1`
        else
            echo "ERROR: Window $id could not be imaged" | tee -a $logfile           
        endif
        rm -rf $src.$id.map $src.$id.beam $src.$id.sen
        set i=`expr $i + 1`
    end
    # Merge the maps (after noise normalization) and plot.
    rm -rf $src.snr $src.gain
    imcat in="$src.*.snr" out=$src.snr options=relax
    puthd in=$src.snr/bunit value='SIGMA'
    imcat in="$src.*.gain" out=$src.gain options=relax
    set max=`histo in=$src.snr | grep Max | awk '{printf "%d",$3+0.5}'`
    if ($max > 50) then
        cgdisp in=$src.snr,$src.gain type=p,c range=0,$max,sqr,1 \
        levs1=0.5 options=full,solneg2,black,wedge device=$src.map.ps/ps \
        labtyp=arcsec lines=2,2,2 csize=0.5,0,0.5 olay=$src.olay \
        region=quarter nxy=4,4 slev=a,1
    else
        cgdisp in=$src.snr,$src.snr,$src.gain type=p,c,c range=0,$max,lin,1 \
        levs1=4 levs2=0.5 options=full,solneg2,black,wedge device=$src.map.ps/ps \
        labtyp=arcsec lines=2,1,2,2 csize=0.5,0,0.5 olay=$src.olay \
        region=quarter nxy=4,4 slev=a,1,a,1
    endif
    if ($see == 'y') then
        gv $src.map.ps &
    endif
    rm -rf $src.*.gain $src.*.snr
end

# Create a final gains set for export.
rm -rf $root.gains
gpcopy vis=refant$refant.gains out=$root.gains options=nopass mode=create
if ($nopasscals == 0) then
    gpcopy vis=passcals.mir out=$root.gains options=nocal mode=copy
endif
rm -f README
echo "" >> README
echo "The file $root.gains contains the bandpass and" \
    >> README
echo "time-dependent gains computed by quality." >> README
echo "Apply them with the following MIRIAD commands (n.b. make a backup" \
    >> README
echo "of the raw data first):" >> README
echo "" >> README
echo "1. linecal vis=$proj" >> README
echo "2. gpcopy vis=$root.gains out=$proj options=nocal" >> README
echo "3. uvcat vis=$proj out=$root.cal" >> README
echo "4. gpcopy vis=$root.gains out=$root.cal options=nopass" >> README
echo "" >> README
echo "The linelength gains are created first (1), then the bandpass is copied (2)," \
    >> README
echo "then both are applied (3), and then the time-dependent gains are copied (4)." \
    >> README
echo "This sequence is necessary so that systemp weighting takes the" \
    >> README
echo "amplitude gains into account, via the senmodel parameter." \
    >> README
echo "" >> README
echo "Hybrid mode: use bpsel to select out the bandpass windows that" \
    >> README
echo "correspond to your source, between steps 2 and 3." \
    >> README
echo "" >> README
echo "Caveats: Only the astronomical bandpass is contained in this file" \
    >> README
echo "(not the noise source).  There has been no flagging of data/gains" \
    >> README
echo "(besides shadowing) and no baseline correction has been applied." \
    >> README
echo "Gains have NOT been bootstrapped using the flux calibrator." \
    >> README
echo "" >> README

#----------------------------- GRADE BLOCK -------------------------------
grading:

skip;echo "*** Grading the project"

echo " " | tee -a $logfile
# Calculate mean and median values
@ N = 1
set value=(0 0 0)
foreach var (rmspath precipmm tau230)
    rm -f meanmed.out
    echo "Track statistics for ${var}:" | tee -a $logfile
    grep -v '#' $var.log | grep -v ' 0.000' | awk '{print $3}' > tmp.varplt
    meanmed infile=tmp.varplt | tee -a meanmed.out $logfile
    set median = `tail -1 meanmed.out | awk '{print $2}'`
    set mean = `tail -1 meanmed.out | awk '{print $3}'`
    set value[$N] = $median
    @ N++
    echo " " | tee -a $logfile
end

# Calculate the tau values from the tipper - no longer required
# tipper:
# if ($?TIPDIR) then
#     if (-d $TIPDIR) then
#         tipper q $totaltime $CalDate $stoptime $see > TrackTipper
#         head -6 TrackTipper > HeadTipper
#         set tautip=`grep Mean HeadTipper | awk '{print $6}'`
#         # Check that tautip is defined and is a number (17aug07)
#         if ($tautip == '' || `echo $tautip | sed 's/[0-9]*\.*[0-9]*//g'` != '') then
#             unset tautip
#         endif
#         awk '{print $0}' HeadTipper | tee -a $logfile
#         rm -f HeadTipper TrackTipper
#     else
#         echo ""
#         echo "WARNING: directory $TIPDIR for Tipper data not found on $HOST" \
#             | tee -a $logfile
#         echo "WARNING: cannot do tipper calculation" | tee -a $logfile; echo ""
#     endif
# else
#     echo "Tipper calculation skipped; variable TIPDIR not defined" \
#         | tee -a $logfile
# endif

#echo "Using median values and a nominal elevation of 45 deg" | tee -a $logfile
echo "The maximum baseline length for this track is $baselen m" | tee -a $logfile
#echo "The median baseline length for this track is $baselen m" | tee -a $logfile

# Rmspath score, referenced to either 112 or 230 GHz
set intfreq=`calc -i "$lofreq"`
if (($intfreq < 150)&&($intfreq > 60)) then
    set reffreq = $ref3mm
endif 
if ($intfreq > 150) then
    set reffreq = $ref1mm
endif
if ($intfreq <60) then
    set reffreq = $ref1cm
endif
if ($reffreq == '0') then
    set reffreq=$lofreq
    set lambda2=$lambda
else
    set lambda2=`calc -f f8.6 "0.3/$reffreq"`
endif
set rmstau = `calc "$value[1]*2*PI/($lambda2*1e6)"`
set rmstau = `calc -f f6.2 "0.5*($rmstau**2)*($baselen/100)**0.833"`
echo "Effective opacity at $reffreq GHz due to phase noise: $rmstau" \
    | tee -a $logfile
echo "" | tee -a $logfile

# Precipmm score based on tipper data, referenced to either 112 or 230 GHz
if ("$tau230" == '') then
    echo "Atmospheric opacity based on tau225 from the tipper" | tee -a $logfile
    #set pwv=`calc -f f6.2 "($value[3]-0.005)/0.06"`
    #set pwv=$value[2]
    if ($intfreq < 150) then
        # convert to mmh2o for obstau input
        set pwv=`calc -f f6.2 "($value[3]-0.005)/0.06"`
        # calculate tau(freq,zenith) for 3mm band
        set tauz=`obstau altitude=2.2 freq=$reffreq mmh2o=$pwv | tail -1 | awk '{print $8}'`
        # calculate tau(freq,45deg)
        set pwvtau=$tauz # no elev correction
        #set pwvtau=`calc -f f6.2 "$tauz*1.414"`
    else
        # calculate tau(freq,45deg)
        set pwvtau=$value[3] # no elev correction
        #set pwvtau=`calc -f f6.2 "$value[3]*1.414"`
    endif
    echo "Opacity at $reffreq GHz due to atmospheric absorption: $pwvtau" | tee -a $logfile
else
    echo "User-specified value of tau230 is: $tau230" | tee -a $logfile
    #set pwv=`calc -f f6.2 "($tau230-0.005)/0.06"`
    if ($intfreq < 150) then
        # convert to mmh2o for obstau input
        set pwv=`calc -f f6.2 "($tau230-0.005)/0.06"`
        # calculate tau(freq,zenith) for 3mm band
        set tauz=`obstau altitude=2.2 freq=$reffreq mmh2o=$pwv | tail -1 | awk '{print $8}'`
        # calculate tau(freq,45deg)
        set pwvtau=$tauz # no elev correction
        #set pwvtau=`calc -f f6.2 "$tauz*1.414"`
    else
        # calculate tau(freq,45deg)
        set pwvtau=$tau230 # no elev correction
        #set pwvtau=`calc -f f6.2 "$tau230*1.414"`
    endif
    echo "Opacity at $reffreq GHz due to atmospheric absorption: $pwvtau" | tee -a $logfile
endif

# Composite score
echo " " | tee -a $logfile
set tottau = `calc -f f6.2 "$rmstau+$pwvtau"`
echo "Total opacity: $tottau" | tee -a $logfile
#set finscore = `calc -i "100-25*(exp($tottau)-1)"`
#echo "COMPOSITE SCORE = 100-25*(exp(tau)-1) = $finscore" | tee -a $logfile
#set finscore = `calc -i "100-25*$tottau"`
#echo "COMPOSITE SCORE = 100-(25*tau) = $finscore" | tee -a $logfile
# Slope=25 too steep for usable 1mm data?
# If rmspath criteria are okay, then slope should change with configuration.
# E = 16, D = 21, C = 19, B = 19, Bw/PACS=14, Aw/PACS=13
#set finscore = `calc -i "100-21*$tottau"`
#echo "COMPOSITE SCORE = 100-(21*tau) = $finscore" | tee -a $logfile
# E = 16, D = 21, C = 19, B = 19, Bw/PACS=14, Aw/PACS=13
if ($arrStr == "SL") then
    set tauGrad = 16
else if ($arrStr == "A") then
    set tauGrad = 13
else if ($arrStr == "B") then
    set tauGrad = 19
else if ($arrStr == "C") then
    set tauGrad = 19 
else if ($arrStr == "D") then
    set tauGrad = 21
else 
    set tauGrad = 16
endif

echo "tottau = $tottau" 

set finscore = `calc -i "100-$tauGrad*$tottau"`
echo "COMPOSITE SCORE = 100-($tauGrad*tau) = $finscore" | tee -a $logfile

echo $tauGrad

# ER HACK
#exit




# Calculate the letter grades
set grade = (0)
@ N = 1
foreach score ($finscore)
    if ($score >= 90) then
        set grade[$N]='A'
    else if ($score >= 80) then
        set grade[$N]='B'
    else if ($score >= 70) then
        set grade[$N]='C'
    else if ($score >= 60) then
        set grade[$N]='D'
    else 
        set grade[$N]='F'
    endif
    if ($grade[$N] != 'D' && $grade[$N] != 'F' && $score < 100) then
        @ remainder = $score % 10
        if ($remainder >= 7) then
            set sign='+'
        else if ($remainder < 3) then
            set sign='-'
        else
            set sign=' '
        endif
    else if ($score >= 100) then
        set sign='+'
    else
        set sign=' '
    endif
    set grade[$N]="$grade[$N]$sign"
    @ N++
end

echo "COMBINED GRADE: $grade[1]" | tee -a $logfile
echo " " | tee -a $logfile
echo "This is based on weather conditions only." | tee -a $logfile

rm -f bsln.out meanmed.out

#--------------------------- CLEANUP BLOCK -------------------------------

if ( $pdb == 'y') then
    qualityGrade project=$prjtag.$obstag opacity=$pwvtau phase=$value[1] \
        grade=$finscore obslen=$totaltime imr=acc
endif

# Convert the log to ps
enscript -r $root.qq.log -o listobs.ps

# List of plots to archive, in order
set list=()
foreach file (listobs rmspath precipmm tau230 tsys1 tsys2 linecal uvphase bimagns_amp bimagns_ph ovrogns_ph bpamp bpph fluxcal)
    if (-e $file.ps) set list=($list $file.ps)
end
foreach file (*.map.ps)
    set list=($list $file)
end
gs -q -dSAFER -dNOPAUSE -dBATCH -sOutputFile=$root.qq.pdf -sDEVICE=pdfwrite -c .setpdfwrite -f $list

# Print the output if desired
if ( "$prn" == "y" ) then
    lp $root.qq.pdf
endif

# Archive the output
if ($?REPORTS) then
    set archpth = $REPORTS/$prjtag/$obstag

    if (! -e $archpth) mkdir -p $archpth
    echo "Archiving quality report ..." 
    cp $logfile $archpth
    tar cvf $root.gains.tar $root.gains README
    cp $root.gains.tar $archpth
    cp $root.qq.pdf $archpth
    skip;echo "Scratch files in $SCRATCH/$prjtag/$obstag"
    echo " will be DELETED in 5 sec - Ctrl-C to interrupt!"
    onintr finish
    sleep 5
    rm -rf $SCRATCH/$prjtag/$obstag
else
    echo ""
    echo "Scratch files in $SCRATCH/$prjtag/$obstag"
    echo " -- please delete these when done"
endif

finish:
onintr
# Finish up
if ($?REPORTS) then
    echo "Archived report in $archpth"
endif
echo ""
echo "If bandpass plots are empty, try repeating with bpsolint=60"
echo "(or other large number) on the command line."
echo ""
echo "To repeat the script, just type:"
echo "$0 proj=$proj sources=$sources gaincals=$gaincals passcals=$passcals fluxcal=$fluxcal"
echo ""

rm -f tmp.*

end:
