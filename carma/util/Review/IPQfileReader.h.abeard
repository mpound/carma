
#ifndef CARMA_UTIL_IPQFILEREADER_H
#define CARMA_UTIL_IPQFILEREADER_H

/**
 * Original author: Steve Scott
 *                  02 Oct, 2002
 *
 * $Id: IPQfileReader.h.abeard,v 1.1 2003/07/16 18:46:09 abeard Exp $
 */



#include "carma/util/IPQfileBuffer.h"

namespace carma {
    namespace util {

/**** REVIEW
 * Reviewer: abeard
 * Comments:  Overall, this is a very nice interface for a templatized class.
 * Personally I find it hard to read templatized interfaces as they 
 * seem messy and foreign.  This is simple enough that it is easy 
 * to understand.
 */

/**
 * 
 * IPQ (InterProcessQueue) provides a generic way for information to be
 * shared between processes or threads. The queues are fixed in length
 * (number of elements) and width (element size). These queues are 
 * persistent files.
 *
 * A templatized class (or structure) is intimately associated with the
 * queue. All writes are done from the local copy, and all reads go into it.
 * Note that all methods of the input class become part of the methods of
 * of the IPQ class, effectively adding the queue methods to the class.
 * The queue storage is simple, with fixed memory allocation, so the input
 * class should have no pointers - just memory. Hierarchies are allowed,
 * as long as it is done with composition and not pointers. Methods
 * have no effect on the queue storage (it may be dangerous to use pointers to
 * the internal data because it is going to get moved around).
 *
 * ***** DANGER *****
 * ** Any class that is virtual (polymorphic = has a vtable = overrides
 * ** a virtual function) will screw up in subtle ways because
 * ** the pointer to the writer's vtable will get copied into
 * ** the reader's object -> not what you want!
 * *****************
 *
 * The queues have independent read and write pointers. The write pointers
 * are an intrinsic part of each queue, but the read pointers are unique
 * to each instance of a reader. The read pointer is initialized in the 
 * constructor to point to the oldest data in the queue.
 *
 * The constructors can throw exceptions - make sure that you catch them!
 *
 * Example of use:
 * <PRE>
 * Class X {
 * public:
 *     double getA() { return A; }
 *     int    getB() { return B; }
 *     char   getC() { return C; }
 *     void   setB(int b) { B=b; }
 * private:
 *     char   C;
 *     double A;
 *     int    B;
 * };
 *
 * // Open an existing queue containing X's 
 * try {
 *    IPQfileReader<X> Xreader("x.ipq");
 * } catch (Error e) { cout<<e; exit(); }
 * Xreader.read()      // Read the first X from queue (into internal X)
 * cout<<Xreader.getB()<<endl;  // Will print B from X that was read
 *
 * </PRE>
 *
 */
 
template <class ElementType> 
class IPQfileReader : public IPQfileBuffer, public ElementType {
public:
    
/**** REVIEW
 * Reviewer: abeard
 * Comments: Consider changing below exception specifications to Error.
 */
    /**
    **  Constructor.
    **  The read pointer is initialized to point to the oldest data
    **  in the queue.
    **  @param filenameString Memory mapped or shared memory filename
    **  @see IPQwriter
    */
    IPQfileReader(const string& filenameString, 
              bool  isCreator = false,
              int   nElements = 0) throw(exception) : 
            IPQfileBuffer((char*)((ElementType*)this),  
                    sizeof(ElementType), 
                    filenameString,
                    isCreator, 
                    nElements)
    { 
        init();          
    }
    

private:
    /**
     * Hide the write method to make this a reader.
     */
    void write() throw(exception);

};

}}  // End namespace carma::util

#endif // CARMA_UTIL_IPQFILEREADER_H














