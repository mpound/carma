/**
 * @author Original Dave Mehringer
 * @version $Id: canonicalNamesToTagIDsConfFileWriter.cc,v 1.7 2014/01/14 23:32:27 iws Exp $
 * @usage canonicalNamesToTagIDsConfFileWriter.cc [conffile=[dbms/dbms.conf]] [outfile=[canonicalNamesToTagIDs.conf]]
 * @description
 * creates the configuration file which maps monitor point canonical names
 * to tagIDs. This mapping is gotten from the database. This conf file will 
 * ultimately be used by TagIDAuthority.
 *
 * @key conffile dbms/dbms.conf string file from which to get database config info; the conffile location interpreted by Program::getConfFile()
 * @key outfile canonicalNamesToTagIDs.conf string the name of the file to write, this should ultimately wind up in the source tree under conf/monitor and be checked into cvs
 *
 * @logger DEFAULT_FACILITY carma.dbms.canonicalNamesToTagIDsConfFileWriter
 */

#include <carma/dbms/DBConfigurator.h>
#include <carma/dbms/DBConnection.h>
#include <carma/dbms/MonitorConfigurationDatabase.h>
#include <carma/dbms/TagIDAuthority.h>
#include <carma/util/Program.h>
#include <carma/util/RuntimeDirs.h>
#include <carma/util/Trace.h>
#include <carma/util/Time.h>
#include <carma/util/programLogging.h>

#include <iostream>
#include <fstream>

#include <boost/foreach.hpp>

#include <carma/dbms/DBMS.pb.h>

using namespace std;
using namespace carma::dbms;

typedef std::map<int, std::string> IntStringMap;

int carma::util::Program::main() {
    const string conffile = getConfFile(getStringParameter("conffile"));
    const string outfile = getStringParameter("outfile");
    CPTRACE(carma::util::Trace::TRACE6, "getStringParameter(\"conffile\") " 
            << getStringParameter("conffile"));
    CPTRACE(carma::util::Trace::TRACE6, "getArg0() " << getArg0());
    CPTRACE(carma::util::Trace::TRACE6, "conffile " << conffile);

    IntStringMap tagID2NameMap;
    DBConfigurator dbconf(conffile);
    auto_ptr<DBConnection>dbc;
    auto_ptr<MonitorConfigurationDatabase> mcdb;
    if(DBConnection::isUp(&dbconf)) {
        CPTRACE(carma::util::Trace::TRACEALL, "database is up, "
                << "trying to create a connection...");
        try {
            auto_ptr<DBConnection> temp
                (DBConnectionFactory::createConnection(&dbconf));
            dbc = temp;
            CPTRACE(carma::util::Trace::TRACEALL, "database connection "
                    << "successful");
            auto_ptr<MonitorConfigurationDatabase> temp2
                (new MonitorConfigurationDatabase(dbc.get()));
            mcdb = temp2;
            tagID2NameMap = mcdb->getTagID2NameMap();
        } catch (const DBConnectionException &exc) {
            cerr << "DBConnectionException caught while retrieving tagIDs "
                 << endl;
            exc.report();
            return EXIT_FAILURE;
        }
    } else {
        CPTRACE(carma::util::Trace::TRACE4, "Database cannot be contacted "
                << "so mappings cannot be retrieved");
        return EXIT_FAILURE;
    }

    // text format
    {
        std::ofstream out(outfile.c_str());
        out << "# WARNING: THIS FILE IS AUTOMATICALLY GENERATED BY" << endl;
        out << "# " << getArg0() << endl;
        out << "# $0. DO NOT EDIT IT." << endl;
        out << "# @file" << endl;
        out << "# canonical name to tagID map for monitor points.  This file is generated" << endl;
        out << "# by querying the database" << endl;
        out << "# File last written " << carma::util::Time::getDateTimeString() << endl;
        out << "#" << endl;
        out << "# @author Original: Dave Mehringer" << endl;
        out << "#" << endl;
        out << "# $Id: canonicalNamesToTagIDsConfFileWriter.cc,v 1.7 2014/01/14 23:32:27 iws Exp $" << endl;
        out << "# $CarmaCopyright$" << endl;
        out << endl;

        BOOST_FOREACH(const IntStringMap::value_type &entry, tagID2NameMap) {
            out << entry.second << " = " << entry.first << std::endl;
        }
    }

    // binary format
    {
        // create binary object
        dbmsproto::NameTagidMap ntm;
        BOOST_FOREACH(const IntStringMap::value_type &entry, tagID2NameMap) {
            ntm.add_id(entry.first);
            ntm.add_name(entry.second);
        }

        // serialize it to the output file
        const std::string filename(outfile + ".bin");
        std::fstream out(filename.c_str(), std::ios::out | std::ios::trunc | std::ios::binary);
        if (!ntm.SerializeToOstream(&out)) {
            std::ostringstream oss;
            oss << "Failed to serialize binary output file: " << filename;
            programLogErrorIfPossible(oss.str());
            std::cerr << oss.str() << std::endl;
            return EXIT_FAILURE;
        }
    }

    carma::dbms::TagIDAuthority::configureAuthority(true, conffile);
    carma::dbms::TagIDAuthority &auth = carma::dbms::TagIDAuthority::getAuthority();
    string sig = auth.tagIDNameMapSha1Sum();
    carma::util::frameType frameCount = carma::util::Time::computeCurrentFrame();
    mcdb->insertTagIDNameSignaturesRecord(frameCount, sig);
    return EXIT_SUCCESS;
}
