#include "carma/szautil/DataType.h"
#include "carma/szautil/Exception.h"
#include "carma/szautil/MpmlGen.h"
#include "carma/szautil/String.h"

#include "carma/szaarrayutils/szaregs.h"

using namespace std;
using namespace sza::util;
using namespace sza::array;

/**.......................................................................
 * Constructor.
 */
MpmlGen::MpmlGen() 
{
  outputDirectory_ = ".";
}

/**.......................................................................
 * Destructor.
 */
MpmlGen::~MpmlGen() {}

/**.......................................................................
 * Set the output directory into which we will generate all MPML files
 */
void MpmlGen::setOutputDirectory(std::string dir)
{
  outputDirectory_ = dir;
}

/**.......................................................................
 * Generate a single MIML file that will represent this regmap structure
 */
void MpmlGen::writeSzaMpmlTemplate()
{
  sza::util::TimeVal time;
  time.setToCurrentTime();

  // Get a reference to the SZA antenna register map

  SzaRegMap* regMap = 0;
  regMap = new_SzaAntRegMap();

  if(regMap == 0) {
    ThrowError("Unable to allocate SZA antenna map");
  }

  std::ostringstream os;
  os << outputDirectory_ << "/SzaSubsystemCommon.mpml";
  std::ofstream fout(os.str().c_str(), ios::out);

  //------------------------------------------------------------
  // Write the header
  //------------------------------------------------------------

  fout << "<?xml version=\"1.0\"?>" << std::endl;
  fout << "<!DOCTYPE Common SYSTEM \"mpml.dtd\">" << std::endl;
  fout << "<!-- ========================================================== -->" << std::endl;
  fout << "<!-- This is an automatically-generated MIML file for inclusion -->" << std::endl;
  fout << "<!-- into the SzaSubsystem.mpml file.                           -->" << std::endl;
  fout << "<!--                                                            -->" << std::endl;
  fout << "<!-- Do not edit this file!                                     -->" << std::endl;
  fout << "<!--                                                            -->" << std::endl;
  fout << "<!-- File was generated at: " << time << "            -->" << std::endl;
  fout << "<!-- ========================================================== -->" << std::endl;
  fout << std::endl;
  fout << "<Common scope=\"global\">" << std::endl << std::endl;

  //------------------------------------------------------------  
  // Now iterate through each board of this register map, generating
  // an MPML template for each one
  //------------------------------------------------------------  

  for(unsigned iBoard=0; iBoard < (unsigned)regMap->nboard_; iBoard++)
    writeMpmlBoardTemplate(fout, regMap->boards_[iBoard]);

  // Now finish and close the file

  fout << "</Common>" << std::endl;

  fout.close();

  // If resources were successfully allocated, delete them now
  
  if(regMap) {
    delete regMap;
  }
}

/**.......................................................................
 * Write an MPML container for a single board
 */
void MpmlGen::writeMpmlBoardTemplate(std::ofstream& fout, RegMapBoard* board)
{
  //------------------------------------------------------------
  // Write the header for this board
  //------------------------------------------------------------

  fout << "  <!-- ========================================================= -->" << std::endl;
  fout << "  <!-- Monitor points of the SZA " << board->name << " subsystem -->" << std::endl;
  fout << "  <!-- ========================================================= -->" << std::endl;
  fout << std::endl;
  fout << "  <Container name=\"" << String::firstToUpper(board->name) << "\" priority=\"normal\">" << std::endl;
  fout << "    <description>" << std::endl;

  fout << "      ";
  appendStringWithHtmlSubstitution(fout, board->comment_);
  fout << std::endl;

  fout << "    </description>" << std::endl << std::endl;

  //------------------------------------------------------------
  // Write the blocks for this board 
  //------------------------------------------------------------

  for(unsigned iBlock=0; iBlock < (unsigned)board->nblock; iBlock++) {
    writeMpmlRegTemplate(fout, board->blocks[iBlock]);
 }

  fout << "  </Container> <!-- " << "sza*." << board->name << " -->" << std::endl << std::endl;
}

/**.......................................................................
 * Write an MPML container for a single register
 */
void MpmlGen::writeMpmlRegTemplate(std::ofstream& fout, RegMapBlock* block)
{
  //------------------------------------------------------------
  // Write the header for this block
  //------------------------------------------------------------

  fout << "    <MonitorPoint ";
  fout << " name=\"" << block->name_ << "\"";
  fout << " type=\"" << DataType::carmaTypeString(block) << "\"";

  if(block->nEl() > 1 && !block->isString())
    fout << " count=\"" << block->nEl() << "\"";

  fout << " priority=\"vital\">" << std::endl;

  fout << "      <shortName>" << block->name_ << "</shortName>" << std::endl;
  fout << "      <longName>" << block->name_ << "</longName>" << std::endl;
  fout << "      <description>" << std::endl;

  //------------------------------------------------------------
  // Append comment field, replacing HTML character entities that
  // conflict with MPML validation with HTML codes
  //------------------------------------------------------------

  fout << "      ";
  appendStringWithHtmlSubstitution(fout, block->comment_);
  fout << std::endl;

  fout << "      </description>" << std::endl;

  if(block->carmaUnits_ == 0 || (*block->carmaUnits_ == "")) {
    fout << "      <units>" << "unknown" << "</units>" << std::endl;
  } else {
    fout << "      <units>" << (*block->carmaUnits_) << "</units>" << std::endl;
  }

  if(block->carmaErrors_) {

    for(unsigned i=0; i < block->carmaErrors_->size(); i++) {

      std::pair<std::string, std::string>& errPair = block->carmaErrors_->at(i);

      if(errPair.first != "") {
	fout << "      <errLo>" << errPair.first << "</errLo>" << std::endl;      
      }

      if(errPair.second != "") {
	fout << "      <errHi>" << errPair.second << "</errHi>" << std::endl;      
      }

    }

  }

  fout << "    </MonitorPoint>" << std::endl << std::endl;
}

/**.......................................................................
 * Generate the code needed to map between my monitor system and carmas
 */
void MpmlGen::writeSzaMonitorPointMapping()
{
  writeSzaMonitorPointMappingHeaderFile();
  writeSzaMonitorPointMappingCcFile();
}

void MpmlGen::writeSzaMonitorPointMappingHeaderFile()
{
  // Get a reference to the SZA antenna register map

  SzaRegMap* regMap = 0;
  regMap = new_SzaAntRegMap();

  if(regMap == 0) {
    ThrowError("Unable to allocate SZA antenna map");
  }

  std::ostringstream os;
  os << outputDirectory_ << "/CarmaMonitorPointTranslator.h";
  std::ofstream fout(os.str().c_str(), ios::out);
  
  //------------------------------------------------------------
  // Write a macro for this subsystem
  //------------------------------------------------------------

  fout << "#include \"carma/monitor/SzaSubsystem.h\"" << std::endl;
  fout << std::endl;
  fout << "namespace sza {" << std::endl;
  fout << "namespace antenna {" << std::endl;
  fout << "namespace corba {" << std::endl;
  fout << std::endl;
  fout << "class CarmaMonitorPointTranslator {" << std::endl;
  fout << "public: " << std::endl;
  fout << std::endl;
  fout << "CarmaMonitorPointTranslator(carma::monitor::SzaSubsystem* base);" << std::endl;
  fout << std::endl;

  fout << "carma::monitor::MonitorPoint& getMonitorPoint(std::string boardName, std::string regName, int iReg=-1);" << std::endl;
  for(unsigned iBoard=0; iBoard < (unsigned)regMap->nboard_; iBoard++) {
    RegMapBoard* board = regMap->boards_[iBoard];
    fout << std::endl;
    fout << "carma::monitor::MonitorPoint& get" << String::firstToUpper(board->name) << "MonitorPoint(std::string regName, int iReg=-1);" << std::endl;
  }

  fout << std::endl;
  fout << "private:" << std::endl;
  fout << std::endl;
  fout << "carma::monitor::SzaSubsystem* base_;"        << std::endl;

  fout << "};" << std::endl;
  fout << "}" << std::endl;
  fout << "}" << std::endl;
  fout << "}" << std::endl;
  fout << std::endl;

  fout.close();

  // Use emacs to indent properly

  emacsIndentFile(os.str());

  if(regMap) {
    delete regMap;
  }
}

void MpmlGen::writeSzaMonitorPointMappingCcFile()
{
  // Get a reference to the SZA antenna register map

  SzaRegMap* regMap = 0;
  regMap = new_SzaAntRegMap();

  if(regMap == 0) {
    ThrowError("Unable to allocate SZA antenna map");
  }

  std::ostringstream os;
  os << outputDirectory_ << "/CarmaMonitorPointTranslator.cc";
  std::ofstream fout(os.str().c_str(), ios::out);
  
  //------------------------------------------------------------
  // Write a macro for this subsystem
  //------------------------------------------------------------

  fout << "#include \"carma/antenna/sza/antenna/corba/CarmaMonitorPointTranslator.h\"" << std::endl;
  fout << "#include \"carma/szautil/Exception.h\"" << std::endl;

  fout << std::endl;
  fout << "using namespace sza::antenna::corba;" << std::endl;
  fout << "using namespace sza::util;" << std::endl;
  fout << std::endl;

  for(unsigned iBoard=0; iBoard < (unsigned)regMap->nboard_; iBoard++) {
    writeBaseBoardMacro(fout, regMap->boards_[iBoard]);
  }

  fout << std::endl;

  fout << "CarmaMonitorPointTranslator::CarmaMonitorPointTranslator(carma::monitor::SzaSubsystem* base)" << std::endl;
  fout << "{" << std::endl;
  fout << "base_  = base;"  << std::endl;
  fout << "}" << std::endl  << std::endl;

  fout << "carma::monitor::MonitorPoint& CarmaMonitorPointTranslator::getMonitorPoint(std::string boardName, std::string regName, int iReg)" << std::endl;
  fout << "{" << std::endl;

  for(unsigned iBoard=0; iBoard < (unsigned)regMap->nboard_; iBoard++) {
    RegMapBoard* board = regMap->boards_[iBoard];
    if(iBoard==0) {
      fout << "if(boardName==\"" << board->name << "\") {" << std::endl;
    } else {
      fout << "else if(boardName==\"" << board->name << "\") {" << std::endl;
    }
    fout << "return get" << String::firstToUpper(board->name) << "MonitorPoint(regName, iReg);" << std::endl;
    fout << "} ";
  }

  fout << "else {" << std::endl;
  fout << " ThrowError(\"Unrecognized board name: \" << boardName);" << std::endl;
  fout << "}";

  fout << std::endl << "}" << std::endl;

  fout << std::endl;

  for(unsigned iBoard=0; iBoard < (unsigned)regMap->nboard_; iBoard++) {
    writeBoardMonitorPointMapping(fout, regMap->boards_[iBoard]);
  }

  fout.close();

  // Use emacs to indent properly

  emacsIndentFile(os.str());

  if(regMap) {
    delete regMap;
  }
}

/**.......................................................................w
 * Write an MPML container for a single board
 */
void MpmlGen::writeBaseBoardMacro(std::ofstream& fout, RegMapBoard* board)
{
  fout << "#define " << String::toUpper(board->name) << "_SUBSYSTEM(mpFn) "
       << "base_->" << board->name << "().mpFn()" << std::endl;

  fout << "#define " << String::toUpper(board->name) << "_SUBSYSTEM_IDX(mpFn, iReg) "
       << "base_->" << board->name << "().mpFn(iReg)" << std::endl;
}

/**.......................................................................w
 * Write an MPML container for a single board
 */
void MpmlGen::writeBoardMonitorPointMapping(std::ofstream& fout, RegMapBoard* board)
{
  //------------------------------------------------------------
  // Write the blocks for this board 
  //------------------------------------------------------------

  fout << "carma::monitor::MonitorPoint& CarmaMonitorPointTranslator::get" << String::firstToUpper(board->name) << "MonitorPoint(std::string regName, int iReg)" << std::endl;
  fout << "{" << std::endl;

  for(unsigned iBlock=0; iBlock < (unsigned)board->nblock; iBlock++) {
    writeRegMonitorPointMapping(fout, board, board->blocks[iBlock], iBlock==0);
 }

  fout << " else {" << std::endl;
  fout << " ThrowError(\"Unrecognized register name: \" << regName);" << std::endl;
  fout << "}" << std::endl;
  fout << "}" << std::endl;
}

/**.......................................................................
 * Write a single entry for the current block
 */
void MpmlGen::writeRegMonitorPointMapping(std::ofstream& fout, RegMapBoard* board, RegMapBlock* block, bool first)
{
  if(first) {
    fout << "if(regName == \"" << block->name_ << "\") {" << std::endl;
  } else {
    fout << " else if(regName == \"" << block->name_ << "\") {" << std::endl;
  }

  if(block->nEl() > 1 && !block->isString()) {
    fout << "  return " << String::toUpper(board->name) << "_SUBSYSTEM_IDX(" << block->name_ << ", iReg);" << std::endl;
  } else {
    fout << "  return " << String::toUpper(board->name) << "_SUBSYSTEM(" << block->name_ << ");" << std::endl;
  }

  fout << "}";
}

void MpmlGen::emacsIndentFile(std::string fileName)
{
  std::ostringstream os;
  os << "emacs " << fileName << " -batch -l " << TOP << "/scripts/emacs_macros -f tab-c++-and-save";
  system(os.str().c_str());
}

void MpmlGen::appendStringWithHtmlSubstitution(std::ofstream& fout, std::string* str)
{
  for(unsigned i=0; i < str->length(); i++) {

    char c = str->at(i);

    switch (c) {
    case '<':
      fout << "&lt;";
      break;
    case '>':
      fout << "&gt;";
      break;
    default:
      fout << c;
      break;
    }
  }
}
